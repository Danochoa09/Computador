Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND_SYM
    ARRAY
    DIRECTIVE
    FALSE
    FOR
    LABEL
    LBRACE
    MATRIX
    OR_SYM
    RBRACE
    RETURN
    SEMI
    STRING
    TRUE

Grammar

Rule 0     S' -> program
Rule 1     program -> stmts
Rule 2     stmts -> stmt stmts
Rule 3     stmts -> <empty>
Rule 4     stmt -> NAME EQUALS MEMREF
Rule 5     stmt -> MEMREF EQUALS NAME
Rule 6     stmt -> NAME EQUALS NUMBER
Rule 7     stmt -> NAME EQUALS NAME
Rule 8     stmt -> NAME EQUALS NAME PLUS NAME
Rule 9     stmt -> NAME EQUALS NAME MINUS NAME
Rule 10    stmt -> NAME EQUALS NAME PLUS NUMBER
Rule 11    stmt -> NAME EQUALS NAME MINUS NUMBER
Rule 12    stmt -> NAME EQUALS NAME TIMES NAME
Rule 13    stmt -> NAME EQUALS NAME TIMES NUMBER
Rule 14    stmt -> NAME EQUALS expr
Rule 15    stmt -> NAME ASSIGN_OP expr
Rule 16    stmt -> REGISTER EQUALS expr
Rule 17    stmt -> REGISTER ASSIGN_OP expr
Rule 18    expr -> expr PLUS expr
Rule 19    expr -> expr MINUS expr
Rule 20    expr -> expr TIMES expr
Rule 21    expr -> MINUS expr
Rule 22    expr -> LPAREN expr RPAREN
Rule 23    expr -> NUMBER
Rule 24    expr -> NAME
Rule 25    expr -> MEMREF
Rule 26    expr -> NAME LBRACKET NUMBER RBRACKET
Rule 27    stmt -> NAME LBRACKET NUMBER RBRACKET EQUALS expr
Rule 28    stmt -> NAME LBRACKET NUMBER RBRACKET ASSIGN_OP expr
Rule 29    stmt -> WHILE NAME NE NAME COLON BEGIN stmts END
Rule 30    stmt -> WHILE NAME NE NUMBER COLON BEGIN stmts END
Rule 31    stmt -> WHILE NAME LT NAME COLON BEGIN stmts END
Rule 32    stmt -> WHILE NAME LT NUMBER COLON BEGIN stmts END
Rule 33    cond -> cond AND cond
Rule 34    cond -> cond OR cond
Rule 35    cond -> NOT cond
Rule 36    cond -> NAME EQEQ NAME
Rule 37    cond -> NAME NE NAME
Rule 38    cond -> NAME LT NAME
Rule 39    cond -> NAME LE NAME
Rule 40    cond -> NAME GT NAME
Rule 41    cond -> NAME GE NAME
Rule 42    cond -> NAME EQEQ NUMBER
Rule 43    cond -> NAME NE NUMBER
Rule 44    cond -> NAME LT NUMBER
Rule 45    cond -> NAME LE NUMBER
Rule 46    cond -> NAME GT NUMBER
Rule 47    cond -> NAME GE NUMBER
Rule 48    stmt -> IF cond COLON BEGIN stmts END
Rule 49    stmt -> WHILE cond COLON BEGIN stmts END
Rule 50    stmt -> WHILE NAME GT NAME COLON BEGIN stmts END
Rule 51    stmt -> WHILE NAME GT NUMBER COLON BEGIN stmts END
Rule 52    stmt -> VAR NAME
Rule 53    stmt -> VAR NAME LBRACKET NUMBER RBRACKET
Rule 54    stmt -> PROC NAME LPAREN params RPAREN COLON BEGIN stmts END
Rule 55    params -> <empty>
Rule 56    params -> NAME
Rule 57    params -> NAME COMMA params
Rule 58    stmt -> CALL NAME LPAREN args RPAREN
Rule 59    args -> <empty>
Rule 60    args -> expr
Rule 61    args -> expr COMMA args
Rule 62    stmt -> IF NAME GT NAME COLON BEGIN stmts END
Rule 63    stmt -> IF NAME EQEQ NAME COLON BEGIN stmts END
Rule 64    stmt -> IF NAME LT NAME COLON BEGIN stmts END
Rule 65    stmt -> IF NAME EQEQ NUMBER COLON BEGIN stmts END
Rule 66    stmt -> IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END
Rule 67    stmt -> NAME asm_args
Rule 68    asm_args -> <empty>
Rule 69    asm_args -> asm_arg asm_args
Rule 70    asm_arg -> REGISTER
Rule 71    asm_arg -> NUMBER
Rule 72    asm_arg -> MEMREF
Rule 73    asm_arg -> NAME
Rule 74    asm_arg -> COMMA

Terminals, with rules where they appear

AND                  : 33
AND_SYM              : 
ARRAY                : 
ASSIGN_OP            : 15 17 28
BEGIN                : 29 30 31 32 48 49 50 51 54 62 63 64 65 66 66
CALL                 : 58
COLON                : 29 30 31 32 48 49 50 51 54 62 63 64 65 66 66
COMMA                : 57 61 74
DIRECTIVE            : 
ELSE                 : 66
END                  : 29 30 31 32 48 49 50 51 54 62 63 64 65 66 66
EQEQ                 : 36 42 63 65
EQUALS               : 4 5 6 7 8 9 10 11 12 13 14 16 27
FALSE                : 
FOR                  : 
GE                   : 41 47
GT                   : 40 46 50 51 62 66
IF                   : 48 62 63 64 65 66
LABEL                : 
LBRACE               : 
LBRACKET             : 26 27 28 53
LE                   : 39 45
LPAREN               : 22 54 58
LT                   : 31 32 38 44 64
MATRIX               : 
MEMREF               : 4 5 25 72
MINUS                : 9 11 19 21
NAME                 : 4 5 6 7 7 8 8 8 9 9 9 10 10 11 11 12 12 12 13 13 14 15 24 26 27 28 29 29 30 31 31 32 36 36 37 37 38 38 39 39 40 40 41 41 42 43 44 45 46 47 50 50 51 52 53 54 56 57 58 62 62 63 63 64 64 65 66 66 67 73
NE                   : 29 30 37 43
NOT                  : 35
NUMBER               : 6 10 11 13 23 26 27 28 30 32 42 43 44 45 46 47 51 53 65 71
OR                   : 34
OR_SYM               : 
PLUS                 : 8 10 18
PROC                 : 54
RBRACE               : 
RBRACKET             : 26 27 28 53
REGISTER             : 16 17 70
RETURN               : 
RPAREN               : 22 54 58
SEMI                 : 
STRING               : 
TIMES                : 12 13 20
TRUE                 : 
VAR                  : 52 53
WHILE                : 29 30 31 32 49 50 51
error                : 

Nonterminals, with rules where they appear

args                 : 58 61
asm_arg              : 69
asm_args             : 67 69
cond                 : 33 33 34 34 35 48 49
expr                 : 14 15 16 17 18 18 19 19 20 20 21 22 27 28 60 61
params               : 54 57
program              : 0
stmt                 : 2
stmts                : 1 2 29 30 31 32 48 49 50 51 54 62 63 64 65 66 66

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . stmts
    (2) stmts -> . stmt stmts
    (3) stmts -> .
    (4) stmt -> . NAME EQUALS MEMREF
    (5) stmt -> . MEMREF EQUALS NAME
    (6) stmt -> . NAME EQUALS NUMBER
    (7) stmt -> . NAME EQUALS NAME
    (8) stmt -> . NAME EQUALS NAME PLUS NAME
    (9) stmt -> . NAME EQUALS NAME MINUS NAME
    (10) stmt -> . NAME EQUALS NAME PLUS NUMBER
    (11) stmt -> . NAME EQUALS NAME MINUS NUMBER
    (12) stmt -> . NAME EQUALS NAME TIMES NAME
    (13) stmt -> . NAME EQUALS NAME TIMES NUMBER
    (14) stmt -> . NAME EQUALS expr
    (15) stmt -> . NAME ASSIGN_OP expr
    (16) stmt -> . REGISTER EQUALS expr
    (17) stmt -> . REGISTER ASSIGN_OP expr
    (27) stmt -> . NAME LBRACKET NUMBER RBRACKET EQUALS expr
    (28) stmt -> . NAME LBRACKET NUMBER RBRACKET ASSIGN_OP expr
    (29) stmt -> . WHILE NAME NE NAME COLON BEGIN stmts END
    (30) stmt -> . WHILE NAME NE NUMBER COLON BEGIN stmts END
    (31) stmt -> . WHILE NAME LT NAME COLON BEGIN stmts END
    (32) stmt -> . WHILE NAME LT NUMBER COLON BEGIN stmts END
    (48) stmt -> . IF cond COLON BEGIN stmts END
    (49) stmt -> . WHILE cond COLON BEGIN stmts END
    (50) stmt -> . WHILE NAME GT NAME COLON BEGIN stmts END
    (51) stmt -> . WHILE NAME GT NUMBER COLON BEGIN stmts END
    (52) stmt -> . VAR NAME
    (53) stmt -> . VAR NAME LBRACKET NUMBER RBRACKET
    (54) stmt -> . PROC NAME LPAREN params RPAREN COLON BEGIN stmts END
    (58) stmt -> . CALL NAME LPAREN args RPAREN
    (62) stmt -> . IF NAME GT NAME COLON BEGIN stmts END
    (63) stmt -> . IF NAME EQEQ NAME COLON BEGIN stmts END
    (64) stmt -> . IF NAME LT NAME COLON BEGIN stmts END
    (65) stmt -> . IF NAME EQEQ NUMBER COLON BEGIN stmts END
    (66) stmt -> . IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END
    (67) stmt -> . NAME asm_args

    $end            reduce using rule 3 (stmts -> .)
    NAME            shift and go to state 4
    MEMREF          shift and go to state 5
    REGISTER        shift and go to state 6
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    VAR             shift and go to state 9
    PROC            shift and go to state 10
    CALL            shift and go to state 11

    program                        shift and go to state 1
    stmts                          shift and go to state 2
    stmt                           shift and go to state 3

state 1

    (0) S' -> program .



state 2

    (1) program -> stmts .

    $end            reduce using rule 1 (program -> stmts .)


state 3

    (2) stmts -> stmt . stmts
    (2) stmts -> . stmt stmts
    (3) stmts -> .
    (4) stmt -> . NAME EQUALS MEMREF
    (5) stmt -> . MEMREF EQUALS NAME
    (6) stmt -> . NAME EQUALS NUMBER
    (7) stmt -> . NAME EQUALS NAME
    (8) stmt -> . NAME EQUALS NAME PLUS NAME
    (9) stmt -> . NAME EQUALS NAME MINUS NAME
    (10) stmt -> . NAME EQUALS NAME PLUS NUMBER
    (11) stmt -> . NAME EQUALS NAME MINUS NUMBER
    (12) stmt -> . NAME EQUALS NAME TIMES NAME
    (13) stmt -> . NAME EQUALS NAME TIMES NUMBER
    (14) stmt -> . NAME EQUALS expr
    (15) stmt -> . NAME ASSIGN_OP expr
    (16) stmt -> . REGISTER EQUALS expr
    (17) stmt -> . REGISTER ASSIGN_OP expr
    (27) stmt -> . NAME LBRACKET NUMBER RBRACKET EQUALS expr
    (28) stmt -> . NAME LBRACKET NUMBER RBRACKET ASSIGN_OP expr
    (29) stmt -> . WHILE NAME NE NAME COLON BEGIN stmts END
    (30) stmt -> . WHILE NAME NE NUMBER COLON BEGIN stmts END
    (31) stmt -> . WHILE NAME LT NAME COLON BEGIN stmts END
    (32) stmt -> . WHILE NAME LT NUMBER COLON BEGIN stmts END
    (48) stmt -> . IF cond COLON BEGIN stmts END
    (49) stmt -> . WHILE cond COLON BEGIN stmts END
    (50) stmt -> . WHILE NAME GT NAME COLON BEGIN stmts END
    (51) stmt -> . WHILE NAME GT NUMBER COLON BEGIN stmts END
    (52) stmt -> . VAR NAME
    (53) stmt -> . VAR NAME LBRACKET NUMBER RBRACKET
    (54) stmt -> . PROC NAME LPAREN params RPAREN COLON BEGIN stmts END
    (58) stmt -> . CALL NAME LPAREN args RPAREN
    (62) stmt -> . IF NAME GT NAME COLON BEGIN stmts END
    (63) stmt -> . IF NAME EQEQ NAME COLON BEGIN stmts END
    (64) stmt -> . IF NAME LT NAME COLON BEGIN stmts END
    (65) stmt -> . IF NAME EQEQ NUMBER COLON BEGIN stmts END
    (66) stmt -> . IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END
    (67) stmt -> . NAME asm_args

    $end            reduce using rule 3 (stmts -> .)
    END             reduce using rule 3 (stmts -> .)
    NAME            shift and go to state 4
    MEMREF          shift and go to state 5
    REGISTER        shift and go to state 6
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    VAR             shift and go to state 9
    PROC            shift and go to state 10
    CALL            shift and go to state 11

    stmt                           shift and go to state 3
    stmts                          shift and go to state 12

state 4

    (4) stmt -> NAME . EQUALS MEMREF
    (6) stmt -> NAME . EQUALS NUMBER
    (7) stmt -> NAME . EQUALS NAME
    (8) stmt -> NAME . EQUALS NAME PLUS NAME
    (9) stmt -> NAME . EQUALS NAME MINUS NAME
    (10) stmt -> NAME . EQUALS NAME PLUS NUMBER
    (11) stmt -> NAME . EQUALS NAME MINUS NUMBER
    (12) stmt -> NAME . EQUALS NAME TIMES NAME
    (13) stmt -> NAME . EQUALS NAME TIMES NUMBER
    (14) stmt -> NAME . EQUALS expr
    (15) stmt -> NAME . ASSIGN_OP expr
    (27) stmt -> NAME . LBRACKET NUMBER RBRACKET EQUALS expr
    (28) stmt -> NAME . LBRACKET NUMBER RBRACKET ASSIGN_OP expr
    (67) stmt -> NAME . asm_args
    (68) asm_args -> .
    (69) asm_args -> . asm_arg asm_args
    (70) asm_arg -> . REGISTER
    (71) asm_arg -> . NUMBER
    (72) asm_arg -> . MEMREF
    (73) asm_arg -> . NAME
    (74) asm_arg -> . COMMA

  ! shift/reduce conflict for REGISTER resolved as shift
  ! shift/reduce conflict for MEMREF resolved as shift
  ! shift/reduce conflict for NAME resolved as shift
    EQUALS          shift and go to state 14
    ASSIGN_OP       shift and go to state 17
    LBRACKET        shift and go to state 18
    WHILE           reduce using rule 68 (asm_args -> .)
    IF              reduce using rule 68 (asm_args -> .)
    VAR             reduce using rule 68 (asm_args -> .)
    PROC            reduce using rule 68 (asm_args -> .)
    CALL            reduce using rule 68 (asm_args -> .)
    $end            reduce using rule 68 (asm_args -> .)
    END             reduce using rule 68 (asm_args -> .)
    REGISTER        shift and go to state 21
    NUMBER          shift and go to state 16
    MEMREF          shift and go to state 15
    NAME            shift and go to state 13
    COMMA           shift and go to state 22

  ! NAME            [ reduce using rule 68 (asm_args -> .) ]
  ! MEMREF          [ reduce using rule 68 (asm_args -> .) ]
  ! REGISTER        [ reduce using rule 68 (asm_args -> .) ]

    asm_args                       shift and go to state 19
    asm_arg                        shift and go to state 20

state 5

    (5) stmt -> MEMREF . EQUALS NAME

    EQUALS          shift and go to state 23


state 6

    (16) stmt -> REGISTER . EQUALS expr
    (17) stmt -> REGISTER . ASSIGN_OP expr

    EQUALS          shift and go to state 24
    ASSIGN_OP       shift and go to state 25


state 7

    (29) stmt -> WHILE . NAME NE NAME COLON BEGIN stmts END
    (30) stmt -> WHILE . NAME NE NUMBER COLON BEGIN stmts END
    (31) stmt -> WHILE . NAME LT NAME COLON BEGIN stmts END
    (32) stmt -> WHILE . NAME LT NUMBER COLON BEGIN stmts END
    (49) stmt -> WHILE . cond COLON BEGIN stmts END
    (50) stmt -> WHILE . NAME GT NAME COLON BEGIN stmts END
    (51) stmt -> WHILE . NAME GT NUMBER COLON BEGIN stmts END
    (33) cond -> . cond AND cond
    (34) cond -> . cond OR cond
    (35) cond -> . NOT cond
    (36) cond -> . NAME EQEQ NAME
    (37) cond -> . NAME NE NAME
    (38) cond -> . NAME LT NAME
    (39) cond -> . NAME LE NAME
    (40) cond -> . NAME GT NAME
    (41) cond -> . NAME GE NAME
    (42) cond -> . NAME EQEQ NUMBER
    (43) cond -> . NAME NE NUMBER
    (44) cond -> . NAME LT NUMBER
    (45) cond -> . NAME LE NUMBER
    (46) cond -> . NAME GT NUMBER
    (47) cond -> . NAME GE NUMBER

    NAME            shift and go to state 26
    NOT             shift and go to state 28

    cond                           shift and go to state 27

state 8

    (48) stmt -> IF . cond COLON BEGIN stmts END
    (62) stmt -> IF . NAME GT NAME COLON BEGIN stmts END
    (63) stmt -> IF . NAME EQEQ NAME COLON BEGIN stmts END
    (64) stmt -> IF . NAME LT NAME COLON BEGIN stmts END
    (65) stmt -> IF . NAME EQEQ NUMBER COLON BEGIN stmts END
    (66) stmt -> IF . NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END
    (33) cond -> . cond AND cond
    (34) cond -> . cond OR cond
    (35) cond -> . NOT cond
    (36) cond -> . NAME EQEQ NAME
    (37) cond -> . NAME NE NAME
    (38) cond -> . NAME LT NAME
    (39) cond -> . NAME LE NAME
    (40) cond -> . NAME GT NAME
    (41) cond -> . NAME GE NAME
    (42) cond -> . NAME EQEQ NUMBER
    (43) cond -> . NAME NE NUMBER
    (44) cond -> . NAME LT NUMBER
    (45) cond -> . NAME LE NUMBER
    (46) cond -> . NAME GT NUMBER
    (47) cond -> . NAME GE NUMBER

    NAME            shift and go to state 30
    NOT             shift and go to state 28

    cond                           shift and go to state 29

state 9

    (52) stmt -> VAR . NAME
    (53) stmt -> VAR . NAME LBRACKET NUMBER RBRACKET

    NAME            shift and go to state 31


state 10

    (54) stmt -> PROC . NAME LPAREN params RPAREN COLON BEGIN stmts END

    NAME            shift and go to state 32


state 11

    (58) stmt -> CALL . NAME LPAREN args RPAREN

    NAME            shift and go to state 33


state 12

    (2) stmts -> stmt stmts .

    $end            reduce using rule 2 (stmts -> stmt stmts .)
    END             reduce using rule 2 (stmts -> stmt stmts .)


state 13

    (73) asm_arg -> NAME .

    REGISTER        reduce using rule 73 (asm_arg -> NAME .)
    NUMBER          reduce using rule 73 (asm_arg -> NAME .)
    MEMREF          reduce using rule 73 (asm_arg -> NAME .)
    NAME            reduce using rule 73 (asm_arg -> NAME .)
    COMMA           reduce using rule 73 (asm_arg -> NAME .)
    WHILE           reduce using rule 73 (asm_arg -> NAME .)
    IF              reduce using rule 73 (asm_arg -> NAME .)
    VAR             reduce using rule 73 (asm_arg -> NAME .)
    PROC            reduce using rule 73 (asm_arg -> NAME .)
    CALL            reduce using rule 73 (asm_arg -> NAME .)
    $end            reduce using rule 73 (asm_arg -> NAME .)
    END             reduce using rule 73 (asm_arg -> NAME .)


state 14

    (4) stmt -> NAME EQUALS . MEMREF
    (6) stmt -> NAME EQUALS . NUMBER
    (7) stmt -> NAME EQUALS . NAME
    (8) stmt -> NAME EQUALS . NAME PLUS NAME
    (9) stmt -> NAME EQUALS . NAME MINUS NAME
    (10) stmt -> NAME EQUALS . NAME PLUS NUMBER
    (11) stmt -> NAME EQUALS . NAME MINUS NUMBER
    (12) stmt -> NAME EQUALS . NAME TIMES NAME
    (13) stmt -> NAME EQUALS . NAME TIMES NUMBER
    (14) stmt -> NAME EQUALS . expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . expr TIMES expr
    (21) expr -> . MINUS expr
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . NUMBER
    (24) expr -> . NAME
    (25) expr -> . MEMREF
    (26) expr -> . NAME LBRACKET NUMBER RBRACKET

    MEMREF          shift and go to state 35
    NUMBER          shift and go to state 36
    NAME            shift and go to state 34
    MINUS           shift and go to state 37
    LPAREN          shift and go to state 39

    expr                           shift and go to state 38

state 15

    (72) asm_arg -> MEMREF .

    REGISTER        reduce using rule 72 (asm_arg -> MEMREF .)
    NUMBER          reduce using rule 72 (asm_arg -> MEMREF .)
    MEMREF          reduce using rule 72 (asm_arg -> MEMREF .)
    NAME            reduce using rule 72 (asm_arg -> MEMREF .)
    COMMA           reduce using rule 72 (asm_arg -> MEMREF .)
    WHILE           reduce using rule 72 (asm_arg -> MEMREF .)
    IF              reduce using rule 72 (asm_arg -> MEMREF .)
    VAR             reduce using rule 72 (asm_arg -> MEMREF .)
    PROC            reduce using rule 72 (asm_arg -> MEMREF .)
    CALL            reduce using rule 72 (asm_arg -> MEMREF .)
    $end            reduce using rule 72 (asm_arg -> MEMREF .)
    END             reduce using rule 72 (asm_arg -> MEMREF .)


state 16

    (71) asm_arg -> NUMBER .

    REGISTER        reduce using rule 71 (asm_arg -> NUMBER .)
    NUMBER          reduce using rule 71 (asm_arg -> NUMBER .)
    MEMREF          reduce using rule 71 (asm_arg -> NUMBER .)
    NAME            reduce using rule 71 (asm_arg -> NUMBER .)
    COMMA           reduce using rule 71 (asm_arg -> NUMBER .)
    WHILE           reduce using rule 71 (asm_arg -> NUMBER .)
    IF              reduce using rule 71 (asm_arg -> NUMBER .)
    VAR             reduce using rule 71 (asm_arg -> NUMBER .)
    PROC            reduce using rule 71 (asm_arg -> NUMBER .)
    CALL            reduce using rule 71 (asm_arg -> NUMBER .)
    $end            reduce using rule 71 (asm_arg -> NUMBER .)
    END             reduce using rule 71 (asm_arg -> NUMBER .)


state 17

    (15) stmt -> NAME ASSIGN_OP . expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . expr TIMES expr
    (21) expr -> . MINUS expr
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . NUMBER
    (24) expr -> . NAME
    (25) expr -> . MEMREF
    (26) expr -> . NAME LBRACKET NUMBER RBRACKET

    MINUS           shift and go to state 37
    LPAREN          shift and go to state 39
    NUMBER          shift and go to state 42
    NAME            shift and go to state 40
    MEMREF          shift and go to state 43

    expr                           shift and go to state 41

state 18

    (27) stmt -> NAME LBRACKET . NUMBER RBRACKET EQUALS expr
    (28) stmt -> NAME LBRACKET . NUMBER RBRACKET ASSIGN_OP expr

    NUMBER          shift and go to state 44


state 19

    (67) stmt -> NAME asm_args .

    NAME            reduce using rule 67 (stmt -> NAME asm_args .)
    MEMREF          reduce using rule 67 (stmt -> NAME asm_args .)
    REGISTER        reduce using rule 67 (stmt -> NAME asm_args .)
    WHILE           reduce using rule 67 (stmt -> NAME asm_args .)
    IF              reduce using rule 67 (stmt -> NAME asm_args .)
    VAR             reduce using rule 67 (stmt -> NAME asm_args .)
    PROC            reduce using rule 67 (stmt -> NAME asm_args .)
    CALL            reduce using rule 67 (stmt -> NAME asm_args .)
    $end            reduce using rule 67 (stmt -> NAME asm_args .)
    END             reduce using rule 67 (stmt -> NAME asm_args .)


state 20

    (69) asm_args -> asm_arg . asm_args
    (68) asm_args -> .
    (69) asm_args -> . asm_arg asm_args
    (70) asm_arg -> . REGISTER
    (71) asm_arg -> . NUMBER
    (72) asm_arg -> . MEMREF
    (73) asm_arg -> . NAME
    (74) asm_arg -> . COMMA

  ! shift/reduce conflict for REGISTER resolved as shift
  ! shift/reduce conflict for MEMREF resolved as shift
  ! shift/reduce conflict for NAME resolved as shift
    WHILE           reduce using rule 68 (asm_args -> .)
    IF              reduce using rule 68 (asm_args -> .)
    VAR             reduce using rule 68 (asm_args -> .)
    PROC            reduce using rule 68 (asm_args -> .)
    CALL            reduce using rule 68 (asm_args -> .)
    $end            reduce using rule 68 (asm_args -> .)
    END             reduce using rule 68 (asm_args -> .)
    REGISTER        shift and go to state 21
    NUMBER          shift and go to state 16
    MEMREF          shift and go to state 15
    NAME            shift and go to state 13
    COMMA           shift and go to state 22

  ! NAME            [ reduce using rule 68 (asm_args -> .) ]
  ! MEMREF          [ reduce using rule 68 (asm_args -> .) ]
  ! REGISTER        [ reduce using rule 68 (asm_args -> .) ]

    asm_arg                        shift and go to state 20
    asm_args                       shift and go to state 45

state 21

    (70) asm_arg -> REGISTER .

    REGISTER        reduce using rule 70 (asm_arg -> REGISTER .)
    NUMBER          reduce using rule 70 (asm_arg -> REGISTER .)
    MEMREF          reduce using rule 70 (asm_arg -> REGISTER .)
    NAME            reduce using rule 70 (asm_arg -> REGISTER .)
    COMMA           reduce using rule 70 (asm_arg -> REGISTER .)
    WHILE           reduce using rule 70 (asm_arg -> REGISTER .)
    IF              reduce using rule 70 (asm_arg -> REGISTER .)
    VAR             reduce using rule 70 (asm_arg -> REGISTER .)
    PROC            reduce using rule 70 (asm_arg -> REGISTER .)
    CALL            reduce using rule 70 (asm_arg -> REGISTER .)
    $end            reduce using rule 70 (asm_arg -> REGISTER .)
    END             reduce using rule 70 (asm_arg -> REGISTER .)


state 22

    (74) asm_arg -> COMMA .

    REGISTER        reduce using rule 74 (asm_arg -> COMMA .)
    NUMBER          reduce using rule 74 (asm_arg -> COMMA .)
    MEMREF          reduce using rule 74 (asm_arg -> COMMA .)
    NAME            reduce using rule 74 (asm_arg -> COMMA .)
    COMMA           reduce using rule 74 (asm_arg -> COMMA .)
    WHILE           reduce using rule 74 (asm_arg -> COMMA .)
    IF              reduce using rule 74 (asm_arg -> COMMA .)
    VAR             reduce using rule 74 (asm_arg -> COMMA .)
    PROC            reduce using rule 74 (asm_arg -> COMMA .)
    CALL            reduce using rule 74 (asm_arg -> COMMA .)
    $end            reduce using rule 74 (asm_arg -> COMMA .)
    END             reduce using rule 74 (asm_arg -> COMMA .)


state 23

    (5) stmt -> MEMREF EQUALS . NAME

    NAME            shift and go to state 46


state 24

    (16) stmt -> REGISTER EQUALS . expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . expr TIMES expr
    (21) expr -> . MINUS expr
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . NUMBER
    (24) expr -> . NAME
    (25) expr -> . MEMREF
    (26) expr -> . NAME LBRACKET NUMBER RBRACKET

    MINUS           shift and go to state 37
    LPAREN          shift and go to state 39
    NUMBER          shift and go to state 42
    NAME            shift and go to state 40
    MEMREF          shift and go to state 43

    expr                           shift and go to state 47

state 25

    (17) stmt -> REGISTER ASSIGN_OP . expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . expr TIMES expr
    (21) expr -> . MINUS expr
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . NUMBER
    (24) expr -> . NAME
    (25) expr -> . MEMREF
    (26) expr -> . NAME LBRACKET NUMBER RBRACKET

    MINUS           shift and go to state 37
    LPAREN          shift and go to state 39
    NUMBER          shift and go to state 42
    NAME            shift and go to state 40
    MEMREF          shift and go to state 43

    expr                           shift and go to state 48

state 26

    (29) stmt -> WHILE NAME . NE NAME COLON BEGIN stmts END
    (30) stmt -> WHILE NAME . NE NUMBER COLON BEGIN stmts END
    (31) stmt -> WHILE NAME . LT NAME COLON BEGIN stmts END
    (32) stmt -> WHILE NAME . LT NUMBER COLON BEGIN stmts END
    (50) stmt -> WHILE NAME . GT NAME COLON BEGIN stmts END
    (51) stmt -> WHILE NAME . GT NUMBER COLON BEGIN stmts END
    (36) cond -> NAME . EQEQ NAME
    (37) cond -> NAME . NE NAME
    (38) cond -> NAME . LT NAME
    (39) cond -> NAME . LE NAME
    (40) cond -> NAME . GT NAME
    (41) cond -> NAME . GE NAME
    (42) cond -> NAME . EQEQ NUMBER
    (43) cond -> NAME . NE NUMBER
    (44) cond -> NAME . LT NUMBER
    (45) cond -> NAME . LE NUMBER
    (46) cond -> NAME . GT NUMBER
    (47) cond -> NAME . GE NUMBER

    NE              shift and go to state 49
    LT              shift and go to state 50
    GT              shift and go to state 51
    EQEQ            shift and go to state 52
    LE              shift and go to state 53
    GE              shift and go to state 54


state 27

    (49) stmt -> WHILE cond . COLON BEGIN stmts END
    (33) cond -> cond . AND cond
    (34) cond -> cond . OR cond

    COLON           shift and go to state 55
    AND             shift and go to state 56
    OR              shift and go to state 57


state 28

    (35) cond -> NOT . cond
    (33) cond -> . cond AND cond
    (34) cond -> . cond OR cond
    (35) cond -> . NOT cond
    (36) cond -> . NAME EQEQ NAME
    (37) cond -> . NAME NE NAME
    (38) cond -> . NAME LT NAME
    (39) cond -> . NAME LE NAME
    (40) cond -> . NAME GT NAME
    (41) cond -> . NAME GE NAME
    (42) cond -> . NAME EQEQ NUMBER
    (43) cond -> . NAME NE NUMBER
    (44) cond -> . NAME LT NUMBER
    (45) cond -> . NAME LE NUMBER
    (46) cond -> . NAME GT NUMBER
    (47) cond -> . NAME GE NUMBER

    NOT             shift and go to state 28
    NAME            shift and go to state 59

    cond                           shift and go to state 58

state 29

    (48) stmt -> IF cond . COLON BEGIN stmts END
    (33) cond -> cond . AND cond
    (34) cond -> cond . OR cond

    COLON           shift and go to state 60
    AND             shift and go to state 56
    OR              shift and go to state 57


state 30

    (62) stmt -> IF NAME . GT NAME COLON BEGIN stmts END
    (63) stmt -> IF NAME . EQEQ NAME COLON BEGIN stmts END
    (64) stmt -> IF NAME . LT NAME COLON BEGIN stmts END
    (65) stmt -> IF NAME . EQEQ NUMBER COLON BEGIN stmts END
    (66) stmt -> IF NAME . GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END
    (36) cond -> NAME . EQEQ NAME
    (37) cond -> NAME . NE NAME
    (38) cond -> NAME . LT NAME
    (39) cond -> NAME . LE NAME
    (40) cond -> NAME . GT NAME
    (41) cond -> NAME . GE NAME
    (42) cond -> NAME . EQEQ NUMBER
    (43) cond -> NAME . NE NUMBER
    (44) cond -> NAME . LT NUMBER
    (45) cond -> NAME . LE NUMBER
    (46) cond -> NAME . GT NUMBER
    (47) cond -> NAME . GE NUMBER

    GT              shift and go to state 61
    EQEQ            shift and go to state 62
    LT              shift and go to state 63
    NE              shift and go to state 64
    LE              shift and go to state 53
    GE              shift and go to state 54


state 31

    (52) stmt -> VAR NAME .
    (53) stmt -> VAR NAME . LBRACKET NUMBER RBRACKET

    NAME            reduce using rule 52 (stmt -> VAR NAME .)
    MEMREF          reduce using rule 52 (stmt -> VAR NAME .)
    REGISTER        reduce using rule 52 (stmt -> VAR NAME .)
    WHILE           reduce using rule 52 (stmt -> VAR NAME .)
    IF              reduce using rule 52 (stmt -> VAR NAME .)
    VAR             reduce using rule 52 (stmt -> VAR NAME .)
    PROC            reduce using rule 52 (stmt -> VAR NAME .)
    CALL            reduce using rule 52 (stmt -> VAR NAME .)
    $end            reduce using rule 52 (stmt -> VAR NAME .)
    END             reduce using rule 52 (stmt -> VAR NAME .)
    LBRACKET        shift and go to state 65


state 32

    (54) stmt -> PROC NAME . LPAREN params RPAREN COLON BEGIN stmts END

    LPAREN          shift and go to state 66


state 33

    (58) stmt -> CALL NAME . LPAREN args RPAREN

    LPAREN          shift and go to state 67


state 34

    (7) stmt -> NAME EQUALS NAME .
    (8) stmt -> NAME EQUALS NAME . PLUS NAME
    (9) stmt -> NAME EQUALS NAME . MINUS NAME
    (10) stmt -> NAME EQUALS NAME . PLUS NUMBER
    (11) stmt -> NAME EQUALS NAME . MINUS NUMBER
    (12) stmt -> NAME EQUALS NAME . TIMES NAME
    (13) stmt -> NAME EQUALS NAME . TIMES NUMBER
    (24) expr -> NAME .
    (26) expr -> NAME . LBRACKET NUMBER RBRACKET

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! reduce/reduce conflict for NAME resolved using rule 7 (stmt -> NAME EQUALS NAME .)
  ! reduce/reduce conflict for MEMREF resolved using rule 7 (stmt -> NAME EQUALS NAME .)
  ! reduce/reduce conflict for REGISTER resolved using rule 7 (stmt -> NAME EQUALS NAME .)
  ! reduce/reduce conflict for WHILE resolved using rule 7 (stmt -> NAME EQUALS NAME .)
  ! reduce/reduce conflict for IF resolved using rule 7 (stmt -> NAME EQUALS NAME .)
  ! reduce/reduce conflict for VAR resolved using rule 7 (stmt -> NAME EQUALS NAME .)
  ! reduce/reduce conflict for PROC resolved using rule 7 (stmt -> NAME EQUALS NAME .)
  ! reduce/reduce conflict for CALL resolved using rule 7 (stmt -> NAME EQUALS NAME .)
  ! reduce/reduce conflict for $end resolved using rule 7 (stmt -> NAME EQUALS NAME .)
  ! reduce/reduce conflict for END resolved using rule 7 (stmt -> NAME EQUALS NAME .)
    NAME            reduce using rule 7 (stmt -> NAME EQUALS NAME .)
    MEMREF          reduce using rule 7 (stmt -> NAME EQUALS NAME .)
    REGISTER        reduce using rule 7 (stmt -> NAME EQUALS NAME .)
    WHILE           reduce using rule 7 (stmt -> NAME EQUALS NAME .)
    IF              reduce using rule 7 (stmt -> NAME EQUALS NAME .)
    VAR             reduce using rule 7 (stmt -> NAME EQUALS NAME .)
    PROC            reduce using rule 7 (stmt -> NAME EQUALS NAME .)
    CALL            reduce using rule 7 (stmt -> NAME EQUALS NAME .)
    $end            reduce using rule 7 (stmt -> NAME EQUALS NAME .)
    END             reduce using rule 7 (stmt -> NAME EQUALS NAME .)
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    TIMES           shift and go to state 70
    LBRACKET        shift and go to state 71

  ! PLUS            [ reduce using rule 24 (expr -> NAME .) ]
  ! MINUS           [ reduce using rule 24 (expr -> NAME .) ]
  ! TIMES           [ reduce using rule 24 (expr -> NAME .) ]
  ! NAME            [ reduce using rule 24 (expr -> NAME .) ]
  ! MEMREF          [ reduce using rule 24 (expr -> NAME .) ]
  ! REGISTER        [ reduce using rule 24 (expr -> NAME .) ]
  ! WHILE           [ reduce using rule 24 (expr -> NAME .) ]
  ! IF              [ reduce using rule 24 (expr -> NAME .) ]
  ! VAR             [ reduce using rule 24 (expr -> NAME .) ]
  ! PROC            [ reduce using rule 24 (expr -> NAME .) ]
  ! CALL            [ reduce using rule 24 (expr -> NAME .) ]
  ! $end            [ reduce using rule 24 (expr -> NAME .) ]
  ! END             [ reduce using rule 24 (expr -> NAME .) ]


state 35

    (4) stmt -> NAME EQUALS MEMREF .
    (25) expr -> MEMREF .

  ! reduce/reduce conflict for NAME resolved using rule 4 (stmt -> NAME EQUALS MEMREF .)
  ! reduce/reduce conflict for MEMREF resolved using rule 4 (stmt -> NAME EQUALS MEMREF .)
  ! reduce/reduce conflict for REGISTER resolved using rule 4 (stmt -> NAME EQUALS MEMREF .)
  ! reduce/reduce conflict for WHILE resolved using rule 4 (stmt -> NAME EQUALS MEMREF .)
  ! reduce/reduce conflict for IF resolved using rule 4 (stmt -> NAME EQUALS MEMREF .)
  ! reduce/reduce conflict for VAR resolved using rule 4 (stmt -> NAME EQUALS MEMREF .)
  ! reduce/reduce conflict for PROC resolved using rule 4 (stmt -> NAME EQUALS MEMREF .)
  ! reduce/reduce conflict for CALL resolved using rule 4 (stmt -> NAME EQUALS MEMREF .)
  ! reduce/reduce conflict for $end resolved using rule 4 (stmt -> NAME EQUALS MEMREF .)
  ! reduce/reduce conflict for END resolved using rule 4 (stmt -> NAME EQUALS MEMREF .)
    NAME            reduce using rule 4 (stmt -> NAME EQUALS MEMREF .)
    MEMREF          reduce using rule 4 (stmt -> NAME EQUALS MEMREF .)
    REGISTER        reduce using rule 4 (stmt -> NAME EQUALS MEMREF .)
    WHILE           reduce using rule 4 (stmt -> NAME EQUALS MEMREF .)
    IF              reduce using rule 4 (stmt -> NAME EQUALS MEMREF .)
    VAR             reduce using rule 4 (stmt -> NAME EQUALS MEMREF .)
    PROC            reduce using rule 4 (stmt -> NAME EQUALS MEMREF .)
    CALL            reduce using rule 4 (stmt -> NAME EQUALS MEMREF .)
    $end            reduce using rule 4 (stmt -> NAME EQUALS MEMREF .)
    END             reduce using rule 4 (stmt -> NAME EQUALS MEMREF .)
    PLUS            reduce using rule 25 (expr -> MEMREF .)
    MINUS           reduce using rule 25 (expr -> MEMREF .)
    TIMES           reduce using rule 25 (expr -> MEMREF .)

  ! NAME            [ reduce using rule 25 (expr -> MEMREF .) ]
  ! MEMREF          [ reduce using rule 25 (expr -> MEMREF .) ]
  ! REGISTER        [ reduce using rule 25 (expr -> MEMREF .) ]
  ! WHILE           [ reduce using rule 25 (expr -> MEMREF .) ]
  ! IF              [ reduce using rule 25 (expr -> MEMREF .) ]
  ! VAR             [ reduce using rule 25 (expr -> MEMREF .) ]
  ! PROC            [ reduce using rule 25 (expr -> MEMREF .) ]
  ! CALL            [ reduce using rule 25 (expr -> MEMREF .) ]
  ! $end            [ reduce using rule 25 (expr -> MEMREF .) ]
  ! END             [ reduce using rule 25 (expr -> MEMREF .) ]


state 36

    (6) stmt -> NAME EQUALS NUMBER .
    (23) expr -> NUMBER .

  ! reduce/reduce conflict for NAME resolved using rule 6 (stmt -> NAME EQUALS NUMBER .)
  ! reduce/reduce conflict for MEMREF resolved using rule 6 (stmt -> NAME EQUALS NUMBER .)
  ! reduce/reduce conflict for REGISTER resolved using rule 6 (stmt -> NAME EQUALS NUMBER .)
  ! reduce/reduce conflict for WHILE resolved using rule 6 (stmt -> NAME EQUALS NUMBER .)
  ! reduce/reduce conflict for IF resolved using rule 6 (stmt -> NAME EQUALS NUMBER .)
  ! reduce/reduce conflict for VAR resolved using rule 6 (stmt -> NAME EQUALS NUMBER .)
  ! reduce/reduce conflict for PROC resolved using rule 6 (stmt -> NAME EQUALS NUMBER .)
  ! reduce/reduce conflict for CALL resolved using rule 6 (stmt -> NAME EQUALS NUMBER .)
  ! reduce/reduce conflict for $end resolved using rule 6 (stmt -> NAME EQUALS NUMBER .)
  ! reduce/reduce conflict for END resolved using rule 6 (stmt -> NAME EQUALS NUMBER .)
    NAME            reduce using rule 6 (stmt -> NAME EQUALS NUMBER .)
    MEMREF          reduce using rule 6 (stmt -> NAME EQUALS NUMBER .)
    REGISTER        reduce using rule 6 (stmt -> NAME EQUALS NUMBER .)
    WHILE           reduce using rule 6 (stmt -> NAME EQUALS NUMBER .)
    IF              reduce using rule 6 (stmt -> NAME EQUALS NUMBER .)
    VAR             reduce using rule 6 (stmt -> NAME EQUALS NUMBER .)
    PROC            reduce using rule 6 (stmt -> NAME EQUALS NUMBER .)
    CALL            reduce using rule 6 (stmt -> NAME EQUALS NUMBER .)
    $end            reduce using rule 6 (stmt -> NAME EQUALS NUMBER .)
    END             reduce using rule 6 (stmt -> NAME EQUALS NUMBER .)
    PLUS            reduce using rule 23 (expr -> NUMBER .)
    MINUS           reduce using rule 23 (expr -> NUMBER .)
    TIMES           reduce using rule 23 (expr -> NUMBER .)

  ! NAME            [ reduce using rule 23 (expr -> NUMBER .) ]
  ! MEMREF          [ reduce using rule 23 (expr -> NUMBER .) ]
  ! REGISTER        [ reduce using rule 23 (expr -> NUMBER .) ]
  ! WHILE           [ reduce using rule 23 (expr -> NUMBER .) ]
  ! IF              [ reduce using rule 23 (expr -> NUMBER .) ]
  ! VAR             [ reduce using rule 23 (expr -> NUMBER .) ]
  ! PROC            [ reduce using rule 23 (expr -> NUMBER .) ]
  ! CALL            [ reduce using rule 23 (expr -> NUMBER .) ]
  ! $end            [ reduce using rule 23 (expr -> NUMBER .) ]
  ! END             [ reduce using rule 23 (expr -> NUMBER .) ]


state 37

    (21) expr -> MINUS . expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . expr TIMES expr
    (21) expr -> . MINUS expr
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . NUMBER
    (24) expr -> . NAME
    (25) expr -> . MEMREF
    (26) expr -> . NAME LBRACKET NUMBER RBRACKET

    MINUS           shift and go to state 37
    LPAREN          shift and go to state 39
    NUMBER          shift and go to state 42
    NAME            shift and go to state 40
    MEMREF          shift and go to state 43

    expr                           shift and go to state 72

state 38

    (14) stmt -> NAME EQUALS expr .
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (20) expr -> expr . TIMES expr

    NAME            reduce using rule 14 (stmt -> NAME EQUALS expr .)
    MEMREF          reduce using rule 14 (stmt -> NAME EQUALS expr .)
    REGISTER        reduce using rule 14 (stmt -> NAME EQUALS expr .)
    WHILE           reduce using rule 14 (stmt -> NAME EQUALS expr .)
    IF              reduce using rule 14 (stmt -> NAME EQUALS expr .)
    VAR             reduce using rule 14 (stmt -> NAME EQUALS expr .)
    PROC            reduce using rule 14 (stmt -> NAME EQUALS expr .)
    CALL            reduce using rule 14 (stmt -> NAME EQUALS expr .)
    $end            reduce using rule 14 (stmt -> NAME EQUALS expr .)
    END             reduce using rule 14 (stmt -> NAME EQUALS expr .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    TIMES           shift and go to state 75


state 39

    (22) expr -> LPAREN . expr RPAREN
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . expr TIMES expr
    (21) expr -> . MINUS expr
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . NUMBER
    (24) expr -> . NAME
    (25) expr -> . MEMREF
    (26) expr -> . NAME LBRACKET NUMBER RBRACKET

    MINUS           shift and go to state 37
    LPAREN          shift and go to state 39
    NUMBER          shift and go to state 42
    NAME            shift and go to state 40
    MEMREF          shift and go to state 43

    expr                           shift and go to state 76

state 40

    (24) expr -> NAME .
    (26) expr -> NAME . LBRACKET NUMBER RBRACKET

    PLUS            reduce using rule 24 (expr -> NAME .)
    MINUS           reduce using rule 24 (expr -> NAME .)
    TIMES           reduce using rule 24 (expr -> NAME .)
    NAME            reduce using rule 24 (expr -> NAME .)
    MEMREF          reduce using rule 24 (expr -> NAME .)
    REGISTER        reduce using rule 24 (expr -> NAME .)
    WHILE           reduce using rule 24 (expr -> NAME .)
    IF              reduce using rule 24 (expr -> NAME .)
    VAR             reduce using rule 24 (expr -> NAME .)
    PROC            reduce using rule 24 (expr -> NAME .)
    CALL            reduce using rule 24 (expr -> NAME .)
    $end            reduce using rule 24 (expr -> NAME .)
    END             reduce using rule 24 (expr -> NAME .)
    RPAREN          reduce using rule 24 (expr -> NAME .)
    COMMA           reduce using rule 24 (expr -> NAME .)
    LBRACKET        shift and go to state 71


state 41

    (15) stmt -> NAME ASSIGN_OP expr .
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (20) expr -> expr . TIMES expr

    NAME            reduce using rule 15 (stmt -> NAME ASSIGN_OP expr .)
    MEMREF          reduce using rule 15 (stmt -> NAME ASSIGN_OP expr .)
    REGISTER        reduce using rule 15 (stmt -> NAME ASSIGN_OP expr .)
    WHILE           reduce using rule 15 (stmt -> NAME ASSIGN_OP expr .)
    IF              reduce using rule 15 (stmt -> NAME ASSIGN_OP expr .)
    VAR             reduce using rule 15 (stmt -> NAME ASSIGN_OP expr .)
    PROC            reduce using rule 15 (stmt -> NAME ASSIGN_OP expr .)
    CALL            reduce using rule 15 (stmt -> NAME ASSIGN_OP expr .)
    $end            reduce using rule 15 (stmt -> NAME ASSIGN_OP expr .)
    END             reduce using rule 15 (stmt -> NAME ASSIGN_OP expr .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    TIMES           shift and go to state 75


state 42

    (23) expr -> NUMBER .

    PLUS            reduce using rule 23 (expr -> NUMBER .)
    MINUS           reduce using rule 23 (expr -> NUMBER .)
    TIMES           reduce using rule 23 (expr -> NUMBER .)
    NAME            reduce using rule 23 (expr -> NUMBER .)
    MEMREF          reduce using rule 23 (expr -> NUMBER .)
    REGISTER        reduce using rule 23 (expr -> NUMBER .)
    WHILE           reduce using rule 23 (expr -> NUMBER .)
    IF              reduce using rule 23 (expr -> NUMBER .)
    VAR             reduce using rule 23 (expr -> NUMBER .)
    PROC            reduce using rule 23 (expr -> NUMBER .)
    CALL            reduce using rule 23 (expr -> NUMBER .)
    $end            reduce using rule 23 (expr -> NUMBER .)
    END             reduce using rule 23 (expr -> NUMBER .)
    RPAREN          reduce using rule 23 (expr -> NUMBER .)
    COMMA           reduce using rule 23 (expr -> NUMBER .)


state 43

    (25) expr -> MEMREF .

    PLUS            reduce using rule 25 (expr -> MEMREF .)
    MINUS           reduce using rule 25 (expr -> MEMREF .)
    TIMES           reduce using rule 25 (expr -> MEMREF .)
    NAME            reduce using rule 25 (expr -> MEMREF .)
    MEMREF          reduce using rule 25 (expr -> MEMREF .)
    REGISTER        reduce using rule 25 (expr -> MEMREF .)
    WHILE           reduce using rule 25 (expr -> MEMREF .)
    IF              reduce using rule 25 (expr -> MEMREF .)
    VAR             reduce using rule 25 (expr -> MEMREF .)
    PROC            reduce using rule 25 (expr -> MEMREF .)
    CALL            reduce using rule 25 (expr -> MEMREF .)
    $end            reduce using rule 25 (expr -> MEMREF .)
    END             reduce using rule 25 (expr -> MEMREF .)
    RPAREN          reduce using rule 25 (expr -> MEMREF .)
    COMMA           reduce using rule 25 (expr -> MEMREF .)


state 44

    (27) stmt -> NAME LBRACKET NUMBER . RBRACKET EQUALS expr
    (28) stmt -> NAME LBRACKET NUMBER . RBRACKET ASSIGN_OP expr

    RBRACKET        shift and go to state 77


state 45

    (69) asm_args -> asm_arg asm_args .

    NAME            reduce using rule 69 (asm_args -> asm_arg asm_args .)
    MEMREF          reduce using rule 69 (asm_args -> asm_arg asm_args .)
    REGISTER        reduce using rule 69 (asm_args -> asm_arg asm_args .)
    WHILE           reduce using rule 69 (asm_args -> asm_arg asm_args .)
    IF              reduce using rule 69 (asm_args -> asm_arg asm_args .)
    VAR             reduce using rule 69 (asm_args -> asm_arg asm_args .)
    PROC            reduce using rule 69 (asm_args -> asm_arg asm_args .)
    CALL            reduce using rule 69 (asm_args -> asm_arg asm_args .)
    $end            reduce using rule 69 (asm_args -> asm_arg asm_args .)
    END             reduce using rule 69 (asm_args -> asm_arg asm_args .)


state 46

    (5) stmt -> MEMREF EQUALS NAME .

    NAME            reduce using rule 5 (stmt -> MEMREF EQUALS NAME .)
    MEMREF          reduce using rule 5 (stmt -> MEMREF EQUALS NAME .)
    REGISTER        reduce using rule 5 (stmt -> MEMREF EQUALS NAME .)
    WHILE           reduce using rule 5 (stmt -> MEMREF EQUALS NAME .)
    IF              reduce using rule 5 (stmt -> MEMREF EQUALS NAME .)
    VAR             reduce using rule 5 (stmt -> MEMREF EQUALS NAME .)
    PROC            reduce using rule 5 (stmt -> MEMREF EQUALS NAME .)
    CALL            reduce using rule 5 (stmt -> MEMREF EQUALS NAME .)
    $end            reduce using rule 5 (stmt -> MEMREF EQUALS NAME .)
    END             reduce using rule 5 (stmt -> MEMREF EQUALS NAME .)


state 47

    (16) stmt -> REGISTER EQUALS expr .
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (20) expr -> expr . TIMES expr

    NAME            reduce using rule 16 (stmt -> REGISTER EQUALS expr .)
    MEMREF          reduce using rule 16 (stmt -> REGISTER EQUALS expr .)
    REGISTER        reduce using rule 16 (stmt -> REGISTER EQUALS expr .)
    WHILE           reduce using rule 16 (stmt -> REGISTER EQUALS expr .)
    IF              reduce using rule 16 (stmt -> REGISTER EQUALS expr .)
    VAR             reduce using rule 16 (stmt -> REGISTER EQUALS expr .)
    PROC            reduce using rule 16 (stmt -> REGISTER EQUALS expr .)
    CALL            reduce using rule 16 (stmt -> REGISTER EQUALS expr .)
    $end            reduce using rule 16 (stmt -> REGISTER EQUALS expr .)
    END             reduce using rule 16 (stmt -> REGISTER EQUALS expr .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    TIMES           shift and go to state 75


state 48

    (17) stmt -> REGISTER ASSIGN_OP expr .
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (20) expr -> expr . TIMES expr

    NAME            reduce using rule 17 (stmt -> REGISTER ASSIGN_OP expr .)
    MEMREF          reduce using rule 17 (stmt -> REGISTER ASSIGN_OP expr .)
    REGISTER        reduce using rule 17 (stmt -> REGISTER ASSIGN_OP expr .)
    WHILE           reduce using rule 17 (stmt -> REGISTER ASSIGN_OP expr .)
    IF              reduce using rule 17 (stmt -> REGISTER ASSIGN_OP expr .)
    VAR             reduce using rule 17 (stmt -> REGISTER ASSIGN_OP expr .)
    PROC            reduce using rule 17 (stmt -> REGISTER ASSIGN_OP expr .)
    CALL            reduce using rule 17 (stmt -> REGISTER ASSIGN_OP expr .)
    $end            reduce using rule 17 (stmt -> REGISTER ASSIGN_OP expr .)
    END             reduce using rule 17 (stmt -> REGISTER ASSIGN_OP expr .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    TIMES           shift and go to state 75


state 49

    (29) stmt -> WHILE NAME NE . NAME COLON BEGIN stmts END
    (30) stmt -> WHILE NAME NE . NUMBER COLON BEGIN stmts END
    (37) cond -> NAME NE . NAME
    (43) cond -> NAME NE . NUMBER

    NAME            shift and go to state 78
    NUMBER          shift and go to state 79


state 50

    (31) stmt -> WHILE NAME LT . NAME COLON BEGIN stmts END
    (32) stmt -> WHILE NAME LT . NUMBER COLON BEGIN stmts END
    (38) cond -> NAME LT . NAME
    (44) cond -> NAME LT . NUMBER

    NAME            shift and go to state 80
    NUMBER          shift and go to state 81


state 51

    (50) stmt -> WHILE NAME GT . NAME COLON BEGIN stmts END
    (51) stmt -> WHILE NAME GT . NUMBER COLON BEGIN stmts END
    (40) cond -> NAME GT . NAME
    (46) cond -> NAME GT . NUMBER

    NAME            shift and go to state 82
    NUMBER          shift and go to state 83


state 52

    (36) cond -> NAME EQEQ . NAME
    (42) cond -> NAME EQEQ . NUMBER

    NAME            shift and go to state 84
    NUMBER          shift and go to state 85


state 53

    (39) cond -> NAME LE . NAME
    (45) cond -> NAME LE . NUMBER

    NAME            shift and go to state 86
    NUMBER          shift and go to state 87


state 54

    (41) cond -> NAME GE . NAME
    (47) cond -> NAME GE . NUMBER

    NAME            shift and go to state 88
    NUMBER          shift and go to state 89


state 55

    (49) stmt -> WHILE cond COLON . BEGIN stmts END

    BEGIN           shift and go to state 90


state 56

    (33) cond -> cond AND . cond
    (33) cond -> . cond AND cond
    (34) cond -> . cond OR cond
    (35) cond -> . NOT cond
    (36) cond -> . NAME EQEQ NAME
    (37) cond -> . NAME NE NAME
    (38) cond -> . NAME LT NAME
    (39) cond -> . NAME LE NAME
    (40) cond -> . NAME GT NAME
    (41) cond -> . NAME GE NAME
    (42) cond -> . NAME EQEQ NUMBER
    (43) cond -> . NAME NE NUMBER
    (44) cond -> . NAME LT NUMBER
    (45) cond -> . NAME LE NUMBER
    (46) cond -> . NAME GT NUMBER
    (47) cond -> . NAME GE NUMBER

    NOT             shift and go to state 28
    NAME            shift and go to state 59

    cond                           shift and go to state 91

state 57

    (34) cond -> cond OR . cond
    (33) cond -> . cond AND cond
    (34) cond -> . cond OR cond
    (35) cond -> . NOT cond
    (36) cond -> . NAME EQEQ NAME
    (37) cond -> . NAME NE NAME
    (38) cond -> . NAME LT NAME
    (39) cond -> . NAME LE NAME
    (40) cond -> . NAME GT NAME
    (41) cond -> . NAME GE NAME
    (42) cond -> . NAME EQEQ NUMBER
    (43) cond -> . NAME NE NUMBER
    (44) cond -> . NAME LT NUMBER
    (45) cond -> . NAME LE NUMBER
    (46) cond -> . NAME GT NUMBER
    (47) cond -> . NAME GE NUMBER

    NOT             shift and go to state 28
    NAME            shift and go to state 59

    cond                           shift and go to state 92

state 58

    (35) cond -> NOT cond .
    (33) cond -> cond . AND cond
    (34) cond -> cond . OR cond

    COLON           reduce using rule 35 (cond -> NOT cond .)
    AND             reduce using rule 35 (cond -> NOT cond .)
    OR              reduce using rule 35 (cond -> NOT cond .)

  ! AND             [ shift and go to state 56 ]
  ! OR              [ shift and go to state 57 ]


state 59

    (36) cond -> NAME . EQEQ NAME
    (37) cond -> NAME . NE NAME
    (38) cond -> NAME . LT NAME
    (39) cond -> NAME . LE NAME
    (40) cond -> NAME . GT NAME
    (41) cond -> NAME . GE NAME
    (42) cond -> NAME . EQEQ NUMBER
    (43) cond -> NAME . NE NUMBER
    (44) cond -> NAME . LT NUMBER
    (45) cond -> NAME . LE NUMBER
    (46) cond -> NAME . GT NUMBER
    (47) cond -> NAME . GE NUMBER

    EQEQ            shift and go to state 52
    NE              shift and go to state 64
    LT              shift and go to state 93
    LE              shift and go to state 53
    GT              shift and go to state 94
    GE              shift and go to state 54


state 60

    (48) stmt -> IF cond COLON . BEGIN stmts END

    BEGIN           shift and go to state 95


state 61

    (62) stmt -> IF NAME GT . NAME COLON BEGIN stmts END
    (66) stmt -> IF NAME GT . NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END
    (40) cond -> NAME GT . NAME
    (46) cond -> NAME GT . NUMBER

    NAME            shift and go to state 96
    NUMBER          shift and go to state 97


state 62

    (63) stmt -> IF NAME EQEQ . NAME COLON BEGIN stmts END
    (65) stmt -> IF NAME EQEQ . NUMBER COLON BEGIN stmts END
    (36) cond -> NAME EQEQ . NAME
    (42) cond -> NAME EQEQ . NUMBER

    NAME            shift and go to state 98
    NUMBER          shift and go to state 99


state 63

    (64) stmt -> IF NAME LT . NAME COLON BEGIN stmts END
    (38) cond -> NAME LT . NAME
    (44) cond -> NAME LT . NUMBER

    NAME            shift and go to state 100
    NUMBER          shift and go to state 101


state 64

    (37) cond -> NAME NE . NAME
    (43) cond -> NAME NE . NUMBER

    NAME            shift and go to state 102
    NUMBER          shift and go to state 103


state 65

    (53) stmt -> VAR NAME LBRACKET . NUMBER RBRACKET

    NUMBER          shift and go to state 104


state 66

    (54) stmt -> PROC NAME LPAREN . params RPAREN COLON BEGIN stmts END
    (55) params -> .
    (56) params -> . NAME
    (57) params -> . NAME COMMA params

    RPAREN          reduce using rule 55 (params -> .)
    NAME            shift and go to state 105

    params                         shift and go to state 106

state 67

    (58) stmt -> CALL NAME LPAREN . args RPAREN
    (59) args -> .
    (60) args -> . expr
    (61) args -> . expr COMMA args
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . expr TIMES expr
    (21) expr -> . MINUS expr
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . NUMBER
    (24) expr -> . NAME
    (25) expr -> . MEMREF
    (26) expr -> . NAME LBRACKET NUMBER RBRACKET

    RPAREN          reduce using rule 59 (args -> .)
    MINUS           shift and go to state 37
    LPAREN          shift and go to state 39
    NUMBER          shift and go to state 42
    NAME            shift and go to state 40
    MEMREF          shift and go to state 43

    args                           shift and go to state 107
    expr                           shift and go to state 108

state 68

    (8) stmt -> NAME EQUALS NAME PLUS . NAME
    (10) stmt -> NAME EQUALS NAME PLUS . NUMBER

    NAME            shift and go to state 109
    NUMBER          shift and go to state 110


state 69

    (9) stmt -> NAME EQUALS NAME MINUS . NAME
    (11) stmt -> NAME EQUALS NAME MINUS . NUMBER

    NAME            shift and go to state 111
    NUMBER          shift and go to state 112


state 70

    (12) stmt -> NAME EQUALS NAME TIMES . NAME
    (13) stmt -> NAME EQUALS NAME TIMES . NUMBER

    NAME            shift and go to state 113
    NUMBER          shift and go to state 114


state 71

    (26) expr -> NAME LBRACKET . NUMBER RBRACKET

    NUMBER          shift and go to state 115


state 72

    (21) expr -> MINUS expr .
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (20) expr -> expr . TIMES expr

    PLUS            reduce using rule 21 (expr -> MINUS expr .)
    MINUS           reduce using rule 21 (expr -> MINUS expr .)
    TIMES           reduce using rule 21 (expr -> MINUS expr .)
    NAME            reduce using rule 21 (expr -> MINUS expr .)
    MEMREF          reduce using rule 21 (expr -> MINUS expr .)
    REGISTER        reduce using rule 21 (expr -> MINUS expr .)
    WHILE           reduce using rule 21 (expr -> MINUS expr .)
    IF              reduce using rule 21 (expr -> MINUS expr .)
    VAR             reduce using rule 21 (expr -> MINUS expr .)
    PROC            reduce using rule 21 (expr -> MINUS expr .)
    CALL            reduce using rule 21 (expr -> MINUS expr .)
    $end            reduce using rule 21 (expr -> MINUS expr .)
    END             reduce using rule 21 (expr -> MINUS expr .)
    RPAREN          reduce using rule 21 (expr -> MINUS expr .)
    COMMA           reduce using rule 21 (expr -> MINUS expr .)

  ! PLUS            [ shift and go to state 73 ]
  ! MINUS           [ shift and go to state 74 ]
  ! TIMES           [ shift and go to state 75 ]


state 73

    (18) expr -> expr PLUS . expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . expr TIMES expr
    (21) expr -> . MINUS expr
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . NUMBER
    (24) expr -> . NAME
    (25) expr -> . MEMREF
    (26) expr -> . NAME LBRACKET NUMBER RBRACKET

    MINUS           shift and go to state 37
    LPAREN          shift and go to state 39
    NUMBER          shift and go to state 42
    NAME            shift and go to state 40
    MEMREF          shift and go to state 43

    expr                           shift and go to state 116

state 74

    (19) expr -> expr MINUS . expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . expr TIMES expr
    (21) expr -> . MINUS expr
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . NUMBER
    (24) expr -> . NAME
    (25) expr -> . MEMREF
    (26) expr -> . NAME LBRACKET NUMBER RBRACKET

    MINUS           shift and go to state 37
    LPAREN          shift and go to state 39
    NUMBER          shift and go to state 42
    NAME            shift and go to state 40
    MEMREF          shift and go to state 43

    expr                           shift and go to state 117

state 75

    (20) expr -> expr TIMES . expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . expr TIMES expr
    (21) expr -> . MINUS expr
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . NUMBER
    (24) expr -> . NAME
    (25) expr -> . MEMREF
    (26) expr -> . NAME LBRACKET NUMBER RBRACKET

    MINUS           shift and go to state 37
    LPAREN          shift and go to state 39
    NUMBER          shift and go to state 42
    NAME            shift and go to state 40
    MEMREF          shift and go to state 43

    expr                           shift and go to state 118

state 76

    (22) expr -> LPAREN expr . RPAREN
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (20) expr -> expr . TIMES expr

    RPAREN          shift and go to state 119
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    TIMES           shift and go to state 75


state 77

    (27) stmt -> NAME LBRACKET NUMBER RBRACKET . EQUALS expr
    (28) stmt -> NAME LBRACKET NUMBER RBRACKET . ASSIGN_OP expr

    EQUALS          shift and go to state 120
    ASSIGN_OP       shift and go to state 121


state 78

    (29) stmt -> WHILE NAME NE NAME . COLON BEGIN stmts END
    (37) cond -> NAME NE NAME .

  ! shift/reduce conflict for COLON resolved as shift
    COLON           shift and go to state 122
    AND             reduce using rule 37 (cond -> NAME NE NAME .)
    OR              reduce using rule 37 (cond -> NAME NE NAME .)

  ! COLON           [ reduce using rule 37 (cond -> NAME NE NAME .) ]


state 79

    (30) stmt -> WHILE NAME NE NUMBER . COLON BEGIN stmts END
    (43) cond -> NAME NE NUMBER .

  ! shift/reduce conflict for COLON resolved as shift
    COLON           shift and go to state 123
    AND             reduce using rule 43 (cond -> NAME NE NUMBER .)
    OR              reduce using rule 43 (cond -> NAME NE NUMBER .)

  ! COLON           [ reduce using rule 43 (cond -> NAME NE NUMBER .) ]


state 80

    (31) stmt -> WHILE NAME LT NAME . COLON BEGIN stmts END
    (38) cond -> NAME LT NAME .

  ! shift/reduce conflict for COLON resolved as shift
    COLON           shift and go to state 124
    AND             reduce using rule 38 (cond -> NAME LT NAME .)
    OR              reduce using rule 38 (cond -> NAME LT NAME .)

  ! COLON           [ reduce using rule 38 (cond -> NAME LT NAME .) ]


state 81

    (32) stmt -> WHILE NAME LT NUMBER . COLON BEGIN stmts END
    (44) cond -> NAME LT NUMBER .

  ! shift/reduce conflict for COLON resolved as shift
    COLON           shift and go to state 125
    AND             reduce using rule 44 (cond -> NAME LT NUMBER .)
    OR              reduce using rule 44 (cond -> NAME LT NUMBER .)

  ! COLON           [ reduce using rule 44 (cond -> NAME LT NUMBER .) ]


state 82

    (50) stmt -> WHILE NAME GT NAME . COLON BEGIN stmts END
    (40) cond -> NAME GT NAME .

  ! shift/reduce conflict for COLON resolved as shift
    COLON           shift and go to state 126
    AND             reduce using rule 40 (cond -> NAME GT NAME .)
    OR              reduce using rule 40 (cond -> NAME GT NAME .)

  ! COLON           [ reduce using rule 40 (cond -> NAME GT NAME .) ]


state 83

    (51) stmt -> WHILE NAME GT NUMBER . COLON BEGIN stmts END
    (46) cond -> NAME GT NUMBER .

  ! shift/reduce conflict for COLON resolved as shift
    COLON           shift and go to state 127
    AND             reduce using rule 46 (cond -> NAME GT NUMBER .)
    OR              reduce using rule 46 (cond -> NAME GT NUMBER .)

  ! COLON           [ reduce using rule 46 (cond -> NAME GT NUMBER .) ]


state 84

    (36) cond -> NAME EQEQ NAME .

    COLON           reduce using rule 36 (cond -> NAME EQEQ NAME .)
    AND             reduce using rule 36 (cond -> NAME EQEQ NAME .)
    OR              reduce using rule 36 (cond -> NAME EQEQ NAME .)


state 85

    (42) cond -> NAME EQEQ NUMBER .

    COLON           reduce using rule 42 (cond -> NAME EQEQ NUMBER .)
    AND             reduce using rule 42 (cond -> NAME EQEQ NUMBER .)
    OR              reduce using rule 42 (cond -> NAME EQEQ NUMBER .)


state 86

    (39) cond -> NAME LE NAME .

    COLON           reduce using rule 39 (cond -> NAME LE NAME .)
    AND             reduce using rule 39 (cond -> NAME LE NAME .)
    OR              reduce using rule 39 (cond -> NAME LE NAME .)


state 87

    (45) cond -> NAME LE NUMBER .

    COLON           reduce using rule 45 (cond -> NAME LE NUMBER .)
    AND             reduce using rule 45 (cond -> NAME LE NUMBER .)
    OR              reduce using rule 45 (cond -> NAME LE NUMBER .)


state 88

    (41) cond -> NAME GE NAME .

    COLON           reduce using rule 41 (cond -> NAME GE NAME .)
    AND             reduce using rule 41 (cond -> NAME GE NAME .)
    OR              reduce using rule 41 (cond -> NAME GE NAME .)


state 89

    (47) cond -> NAME GE NUMBER .

    COLON           reduce using rule 47 (cond -> NAME GE NUMBER .)
    AND             reduce using rule 47 (cond -> NAME GE NUMBER .)
    OR              reduce using rule 47 (cond -> NAME GE NUMBER .)


state 90

    (49) stmt -> WHILE cond COLON BEGIN . stmts END
    (2) stmts -> . stmt stmts
    (3) stmts -> .
    (4) stmt -> . NAME EQUALS MEMREF
    (5) stmt -> . MEMREF EQUALS NAME
    (6) stmt -> . NAME EQUALS NUMBER
    (7) stmt -> . NAME EQUALS NAME
    (8) stmt -> . NAME EQUALS NAME PLUS NAME
    (9) stmt -> . NAME EQUALS NAME MINUS NAME
    (10) stmt -> . NAME EQUALS NAME PLUS NUMBER
    (11) stmt -> . NAME EQUALS NAME MINUS NUMBER
    (12) stmt -> . NAME EQUALS NAME TIMES NAME
    (13) stmt -> . NAME EQUALS NAME TIMES NUMBER
    (14) stmt -> . NAME EQUALS expr
    (15) stmt -> . NAME ASSIGN_OP expr
    (16) stmt -> . REGISTER EQUALS expr
    (17) stmt -> . REGISTER ASSIGN_OP expr
    (27) stmt -> . NAME LBRACKET NUMBER RBRACKET EQUALS expr
    (28) stmt -> . NAME LBRACKET NUMBER RBRACKET ASSIGN_OP expr
    (29) stmt -> . WHILE NAME NE NAME COLON BEGIN stmts END
    (30) stmt -> . WHILE NAME NE NUMBER COLON BEGIN stmts END
    (31) stmt -> . WHILE NAME LT NAME COLON BEGIN stmts END
    (32) stmt -> . WHILE NAME LT NUMBER COLON BEGIN stmts END
    (48) stmt -> . IF cond COLON BEGIN stmts END
    (49) stmt -> . WHILE cond COLON BEGIN stmts END
    (50) stmt -> . WHILE NAME GT NAME COLON BEGIN stmts END
    (51) stmt -> . WHILE NAME GT NUMBER COLON BEGIN stmts END
    (52) stmt -> . VAR NAME
    (53) stmt -> . VAR NAME LBRACKET NUMBER RBRACKET
    (54) stmt -> . PROC NAME LPAREN params RPAREN COLON BEGIN stmts END
    (58) stmt -> . CALL NAME LPAREN args RPAREN
    (62) stmt -> . IF NAME GT NAME COLON BEGIN stmts END
    (63) stmt -> . IF NAME EQEQ NAME COLON BEGIN stmts END
    (64) stmt -> . IF NAME LT NAME COLON BEGIN stmts END
    (65) stmt -> . IF NAME EQEQ NUMBER COLON BEGIN stmts END
    (66) stmt -> . IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END
    (67) stmt -> . NAME asm_args

    END             reduce using rule 3 (stmts -> .)
    NAME            shift and go to state 4
    MEMREF          shift and go to state 5
    REGISTER        shift and go to state 6
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    VAR             shift and go to state 9
    PROC            shift and go to state 10
    CALL            shift and go to state 11

    stmts                          shift and go to state 128
    stmt                           shift and go to state 3

state 91

    (33) cond -> cond AND cond .
    (33) cond -> cond . AND cond
    (34) cond -> cond . OR cond

    COLON           reduce using rule 33 (cond -> cond AND cond .)
    AND             reduce using rule 33 (cond -> cond AND cond .)
    OR              reduce using rule 33 (cond -> cond AND cond .)

  ! AND             [ shift and go to state 56 ]
  ! OR              [ shift and go to state 57 ]


state 92

    (34) cond -> cond OR cond .
    (33) cond -> cond . AND cond
    (34) cond -> cond . OR cond

    COLON           reduce using rule 34 (cond -> cond OR cond .)
    OR              reduce using rule 34 (cond -> cond OR cond .)
    AND             shift and go to state 56

  ! AND             [ reduce using rule 34 (cond -> cond OR cond .) ]
  ! OR              [ shift and go to state 57 ]


state 93

    (38) cond -> NAME LT . NAME
    (44) cond -> NAME LT . NUMBER

    NAME            shift and go to state 129
    NUMBER          shift and go to state 101


state 94

    (40) cond -> NAME GT . NAME
    (46) cond -> NAME GT . NUMBER

    NAME            shift and go to state 130
    NUMBER          shift and go to state 97


state 95

    (48) stmt -> IF cond COLON BEGIN . stmts END
    (2) stmts -> . stmt stmts
    (3) stmts -> .
    (4) stmt -> . NAME EQUALS MEMREF
    (5) stmt -> . MEMREF EQUALS NAME
    (6) stmt -> . NAME EQUALS NUMBER
    (7) stmt -> . NAME EQUALS NAME
    (8) stmt -> . NAME EQUALS NAME PLUS NAME
    (9) stmt -> . NAME EQUALS NAME MINUS NAME
    (10) stmt -> . NAME EQUALS NAME PLUS NUMBER
    (11) stmt -> . NAME EQUALS NAME MINUS NUMBER
    (12) stmt -> . NAME EQUALS NAME TIMES NAME
    (13) stmt -> . NAME EQUALS NAME TIMES NUMBER
    (14) stmt -> . NAME EQUALS expr
    (15) stmt -> . NAME ASSIGN_OP expr
    (16) stmt -> . REGISTER EQUALS expr
    (17) stmt -> . REGISTER ASSIGN_OP expr
    (27) stmt -> . NAME LBRACKET NUMBER RBRACKET EQUALS expr
    (28) stmt -> . NAME LBRACKET NUMBER RBRACKET ASSIGN_OP expr
    (29) stmt -> . WHILE NAME NE NAME COLON BEGIN stmts END
    (30) stmt -> . WHILE NAME NE NUMBER COLON BEGIN stmts END
    (31) stmt -> . WHILE NAME LT NAME COLON BEGIN stmts END
    (32) stmt -> . WHILE NAME LT NUMBER COLON BEGIN stmts END
    (48) stmt -> . IF cond COLON BEGIN stmts END
    (49) stmt -> . WHILE cond COLON BEGIN stmts END
    (50) stmt -> . WHILE NAME GT NAME COLON BEGIN stmts END
    (51) stmt -> . WHILE NAME GT NUMBER COLON BEGIN stmts END
    (52) stmt -> . VAR NAME
    (53) stmt -> . VAR NAME LBRACKET NUMBER RBRACKET
    (54) stmt -> . PROC NAME LPAREN params RPAREN COLON BEGIN stmts END
    (58) stmt -> . CALL NAME LPAREN args RPAREN
    (62) stmt -> . IF NAME GT NAME COLON BEGIN stmts END
    (63) stmt -> . IF NAME EQEQ NAME COLON BEGIN stmts END
    (64) stmt -> . IF NAME LT NAME COLON BEGIN stmts END
    (65) stmt -> . IF NAME EQEQ NUMBER COLON BEGIN stmts END
    (66) stmt -> . IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END
    (67) stmt -> . NAME asm_args

    END             reduce using rule 3 (stmts -> .)
    NAME            shift and go to state 4
    MEMREF          shift and go to state 5
    REGISTER        shift and go to state 6
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    VAR             shift and go to state 9
    PROC            shift and go to state 10
    CALL            shift and go to state 11

    stmts                          shift and go to state 131
    stmt                           shift and go to state 3

state 96

    (62) stmt -> IF NAME GT NAME . COLON BEGIN stmts END
    (66) stmt -> IF NAME GT NAME . COLON BEGIN stmts END ELSE COLON BEGIN stmts END
    (40) cond -> NAME GT NAME .

  ! shift/reduce conflict for COLON resolved as shift
    COLON           shift and go to state 132
    AND             reduce using rule 40 (cond -> NAME GT NAME .)
    OR              reduce using rule 40 (cond -> NAME GT NAME .)

  ! COLON           [ reduce using rule 40 (cond -> NAME GT NAME .) ]


state 97

    (46) cond -> NAME GT NUMBER .

    COLON           reduce using rule 46 (cond -> NAME GT NUMBER .)
    AND             reduce using rule 46 (cond -> NAME GT NUMBER .)
    OR              reduce using rule 46 (cond -> NAME GT NUMBER .)


state 98

    (63) stmt -> IF NAME EQEQ NAME . COLON BEGIN stmts END
    (36) cond -> NAME EQEQ NAME .

  ! shift/reduce conflict for COLON resolved as shift
    COLON           shift and go to state 133
    AND             reduce using rule 36 (cond -> NAME EQEQ NAME .)
    OR              reduce using rule 36 (cond -> NAME EQEQ NAME .)

  ! COLON           [ reduce using rule 36 (cond -> NAME EQEQ NAME .) ]


state 99

    (65) stmt -> IF NAME EQEQ NUMBER . COLON BEGIN stmts END
    (42) cond -> NAME EQEQ NUMBER .

  ! shift/reduce conflict for COLON resolved as shift
    COLON           shift and go to state 134
    AND             reduce using rule 42 (cond -> NAME EQEQ NUMBER .)
    OR              reduce using rule 42 (cond -> NAME EQEQ NUMBER .)

  ! COLON           [ reduce using rule 42 (cond -> NAME EQEQ NUMBER .) ]


state 100

    (64) stmt -> IF NAME LT NAME . COLON BEGIN stmts END
    (38) cond -> NAME LT NAME .

  ! shift/reduce conflict for COLON resolved as shift
    COLON           shift and go to state 135
    AND             reduce using rule 38 (cond -> NAME LT NAME .)
    OR              reduce using rule 38 (cond -> NAME LT NAME .)

  ! COLON           [ reduce using rule 38 (cond -> NAME LT NAME .) ]


state 101

    (44) cond -> NAME LT NUMBER .

    COLON           reduce using rule 44 (cond -> NAME LT NUMBER .)
    AND             reduce using rule 44 (cond -> NAME LT NUMBER .)
    OR              reduce using rule 44 (cond -> NAME LT NUMBER .)


state 102

    (37) cond -> NAME NE NAME .

    COLON           reduce using rule 37 (cond -> NAME NE NAME .)
    AND             reduce using rule 37 (cond -> NAME NE NAME .)
    OR              reduce using rule 37 (cond -> NAME NE NAME .)


state 103

    (43) cond -> NAME NE NUMBER .

    COLON           reduce using rule 43 (cond -> NAME NE NUMBER .)
    AND             reduce using rule 43 (cond -> NAME NE NUMBER .)
    OR              reduce using rule 43 (cond -> NAME NE NUMBER .)


state 104

    (53) stmt -> VAR NAME LBRACKET NUMBER . RBRACKET

    RBRACKET        shift and go to state 136


state 105

    (56) params -> NAME .
    (57) params -> NAME . COMMA params

    RPAREN          reduce using rule 56 (params -> NAME .)
    COMMA           shift and go to state 137


state 106

    (54) stmt -> PROC NAME LPAREN params . RPAREN COLON BEGIN stmts END

    RPAREN          shift and go to state 138


state 107

    (58) stmt -> CALL NAME LPAREN args . RPAREN

    RPAREN          shift and go to state 139


state 108

    (60) args -> expr .
    (61) args -> expr . COMMA args
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (20) expr -> expr . TIMES expr

    RPAREN          reduce using rule 60 (args -> expr .)
    COMMA           shift and go to state 140
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    TIMES           shift and go to state 75


state 109

    (8) stmt -> NAME EQUALS NAME PLUS NAME .

    NAME            reduce using rule 8 (stmt -> NAME EQUALS NAME PLUS NAME .)
    MEMREF          reduce using rule 8 (stmt -> NAME EQUALS NAME PLUS NAME .)
    REGISTER        reduce using rule 8 (stmt -> NAME EQUALS NAME PLUS NAME .)
    WHILE           reduce using rule 8 (stmt -> NAME EQUALS NAME PLUS NAME .)
    IF              reduce using rule 8 (stmt -> NAME EQUALS NAME PLUS NAME .)
    VAR             reduce using rule 8 (stmt -> NAME EQUALS NAME PLUS NAME .)
    PROC            reduce using rule 8 (stmt -> NAME EQUALS NAME PLUS NAME .)
    CALL            reduce using rule 8 (stmt -> NAME EQUALS NAME PLUS NAME .)
    $end            reduce using rule 8 (stmt -> NAME EQUALS NAME PLUS NAME .)
    END             reduce using rule 8 (stmt -> NAME EQUALS NAME PLUS NAME .)


state 110

    (10) stmt -> NAME EQUALS NAME PLUS NUMBER .

    NAME            reduce using rule 10 (stmt -> NAME EQUALS NAME PLUS NUMBER .)
    MEMREF          reduce using rule 10 (stmt -> NAME EQUALS NAME PLUS NUMBER .)
    REGISTER        reduce using rule 10 (stmt -> NAME EQUALS NAME PLUS NUMBER .)
    WHILE           reduce using rule 10 (stmt -> NAME EQUALS NAME PLUS NUMBER .)
    IF              reduce using rule 10 (stmt -> NAME EQUALS NAME PLUS NUMBER .)
    VAR             reduce using rule 10 (stmt -> NAME EQUALS NAME PLUS NUMBER .)
    PROC            reduce using rule 10 (stmt -> NAME EQUALS NAME PLUS NUMBER .)
    CALL            reduce using rule 10 (stmt -> NAME EQUALS NAME PLUS NUMBER .)
    $end            reduce using rule 10 (stmt -> NAME EQUALS NAME PLUS NUMBER .)
    END             reduce using rule 10 (stmt -> NAME EQUALS NAME PLUS NUMBER .)


state 111

    (9) stmt -> NAME EQUALS NAME MINUS NAME .

    NAME            reduce using rule 9 (stmt -> NAME EQUALS NAME MINUS NAME .)
    MEMREF          reduce using rule 9 (stmt -> NAME EQUALS NAME MINUS NAME .)
    REGISTER        reduce using rule 9 (stmt -> NAME EQUALS NAME MINUS NAME .)
    WHILE           reduce using rule 9 (stmt -> NAME EQUALS NAME MINUS NAME .)
    IF              reduce using rule 9 (stmt -> NAME EQUALS NAME MINUS NAME .)
    VAR             reduce using rule 9 (stmt -> NAME EQUALS NAME MINUS NAME .)
    PROC            reduce using rule 9 (stmt -> NAME EQUALS NAME MINUS NAME .)
    CALL            reduce using rule 9 (stmt -> NAME EQUALS NAME MINUS NAME .)
    $end            reduce using rule 9 (stmt -> NAME EQUALS NAME MINUS NAME .)
    END             reduce using rule 9 (stmt -> NAME EQUALS NAME MINUS NAME .)


state 112

    (11) stmt -> NAME EQUALS NAME MINUS NUMBER .

    NAME            reduce using rule 11 (stmt -> NAME EQUALS NAME MINUS NUMBER .)
    MEMREF          reduce using rule 11 (stmt -> NAME EQUALS NAME MINUS NUMBER .)
    REGISTER        reduce using rule 11 (stmt -> NAME EQUALS NAME MINUS NUMBER .)
    WHILE           reduce using rule 11 (stmt -> NAME EQUALS NAME MINUS NUMBER .)
    IF              reduce using rule 11 (stmt -> NAME EQUALS NAME MINUS NUMBER .)
    VAR             reduce using rule 11 (stmt -> NAME EQUALS NAME MINUS NUMBER .)
    PROC            reduce using rule 11 (stmt -> NAME EQUALS NAME MINUS NUMBER .)
    CALL            reduce using rule 11 (stmt -> NAME EQUALS NAME MINUS NUMBER .)
    $end            reduce using rule 11 (stmt -> NAME EQUALS NAME MINUS NUMBER .)
    END             reduce using rule 11 (stmt -> NAME EQUALS NAME MINUS NUMBER .)


state 113

    (12) stmt -> NAME EQUALS NAME TIMES NAME .

    NAME            reduce using rule 12 (stmt -> NAME EQUALS NAME TIMES NAME .)
    MEMREF          reduce using rule 12 (stmt -> NAME EQUALS NAME TIMES NAME .)
    REGISTER        reduce using rule 12 (stmt -> NAME EQUALS NAME TIMES NAME .)
    WHILE           reduce using rule 12 (stmt -> NAME EQUALS NAME TIMES NAME .)
    IF              reduce using rule 12 (stmt -> NAME EQUALS NAME TIMES NAME .)
    VAR             reduce using rule 12 (stmt -> NAME EQUALS NAME TIMES NAME .)
    PROC            reduce using rule 12 (stmt -> NAME EQUALS NAME TIMES NAME .)
    CALL            reduce using rule 12 (stmt -> NAME EQUALS NAME TIMES NAME .)
    $end            reduce using rule 12 (stmt -> NAME EQUALS NAME TIMES NAME .)
    END             reduce using rule 12 (stmt -> NAME EQUALS NAME TIMES NAME .)


state 114

    (13) stmt -> NAME EQUALS NAME TIMES NUMBER .

    NAME            reduce using rule 13 (stmt -> NAME EQUALS NAME TIMES NUMBER .)
    MEMREF          reduce using rule 13 (stmt -> NAME EQUALS NAME TIMES NUMBER .)
    REGISTER        reduce using rule 13 (stmt -> NAME EQUALS NAME TIMES NUMBER .)
    WHILE           reduce using rule 13 (stmt -> NAME EQUALS NAME TIMES NUMBER .)
    IF              reduce using rule 13 (stmt -> NAME EQUALS NAME TIMES NUMBER .)
    VAR             reduce using rule 13 (stmt -> NAME EQUALS NAME TIMES NUMBER .)
    PROC            reduce using rule 13 (stmt -> NAME EQUALS NAME TIMES NUMBER .)
    CALL            reduce using rule 13 (stmt -> NAME EQUALS NAME TIMES NUMBER .)
    $end            reduce using rule 13 (stmt -> NAME EQUALS NAME TIMES NUMBER .)
    END             reduce using rule 13 (stmt -> NAME EQUALS NAME TIMES NUMBER .)


state 115

    (26) expr -> NAME LBRACKET NUMBER . RBRACKET

    RBRACKET        shift and go to state 141


state 116

    (18) expr -> expr PLUS expr .
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (20) expr -> expr . TIMES expr

    PLUS            reduce using rule 18 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 18 (expr -> expr PLUS expr .)
    NAME            reduce using rule 18 (expr -> expr PLUS expr .)
    MEMREF          reduce using rule 18 (expr -> expr PLUS expr .)
    REGISTER        reduce using rule 18 (expr -> expr PLUS expr .)
    WHILE           reduce using rule 18 (expr -> expr PLUS expr .)
    IF              reduce using rule 18 (expr -> expr PLUS expr .)
    VAR             reduce using rule 18 (expr -> expr PLUS expr .)
    PROC            reduce using rule 18 (expr -> expr PLUS expr .)
    CALL            reduce using rule 18 (expr -> expr PLUS expr .)
    $end            reduce using rule 18 (expr -> expr PLUS expr .)
    END             reduce using rule 18 (expr -> expr PLUS expr .)
    RPAREN          reduce using rule 18 (expr -> expr PLUS expr .)
    COMMA           reduce using rule 18 (expr -> expr PLUS expr .)
    TIMES           shift and go to state 75

  ! TIMES           [ reduce using rule 18 (expr -> expr PLUS expr .) ]
  ! PLUS            [ shift and go to state 73 ]
  ! MINUS           [ shift and go to state 74 ]


state 117

    (19) expr -> expr MINUS expr .
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (20) expr -> expr . TIMES expr

    PLUS            reduce using rule 19 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 19 (expr -> expr MINUS expr .)
    NAME            reduce using rule 19 (expr -> expr MINUS expr .)
    MEMREF          reduce using rule 19 (expr -> expr MINUS expr .)
    REGISTER        reduce using rule 19 (expr -> expr MINUS expr .)
    WHILE           reduce using rule 19 (expr -> expr MINUS expr .)
    IF              reduce using rule 19 (expr -> expr MINUS expr .)
    VAR             reduce using rule 19 (expr -> expr MINUS expr .)
    PROC            reduce using rule 19 (expr -> expr MINUS expr .)
    CALL            reduce using rule 19 (expr -> expr MINUS expr .)
    $end            reduce using rule 19 (expr -> expr MINUS expr .)
    END             reduce using rule 19 (expr -> expr MINUS expr .)
    RPAREN          reduce using rule 19 (expr -> expr MINUS expr .)
    COMMA           reduce using rule 19 (expr -> expr MINUS expr .)
    TIMES           shift and go to state 75

  ! TIMES           [ reduce using rule 19 (expr -> expr MINUS expr .) ]
  ! PLUS            [ shift and go to state 73 ]
  ! MINUS           [ shift and go to state 74 ]


state 118

    (20) expr -> expr TIMES expr .
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (20) expr -> expr . TIMES expr

    PLUS            reduce using rule 20 (expr -> expr TIMES expr .)
    MINUS           reduce using rule 20 (expr -> expr TIMES expr .)
    TIMES           reduce using rule 20 (expr -> expr TIMES expr .)
    NAME            reduce using rule 20 (expr -> expr TIMES expr .)
    MEMREF          reduce using rule 20 (expr -> expr TIMES expr .)
    REGISTER        reduce using rule 20 (expr -> expr TIMES expr .)
    WHILE           reduce using rule 20 (expr -> expr TIMES expr .)
    IF              reduce using rule 20 (expr -> expr TIMES expr .)
    VAR             reduce using rule 20 (expr -> expr TIMES expr .)
    PROC            reduce using rule 20 (expr -> expr TIMES expr .)
    CALL            reduce using rule 20 (expr -> expr TIMES expr .)
    $end            reduce using rule 20 (expr -> expr TIMES expr .)
    END             reduce using rule 20 (expr -> expr TIMES expr .)
    RPAREN          reduce using rule 20 (expr -> expr TIMES expr .)
    COMMA           reduce using rule 20 (expr -> expr TIMES expr .)

  ! PLUS            [ shift and go to state 73 ]
  ! MINUS           [ shift and go to state 74 ]
  ! TIMES           [ shift and go to state 75 ]


state 119

    (22) expr -> LPAREN expr RPAREN .

    PLUS            reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    TIMES           reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    NAME            reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    MEMREF          reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    REGISTER        reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    WHILE           reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    IF              reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    VAR             reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    PROC            reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    CALL            reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    $end            reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    END             reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 22 (expr -> LPAREN expr RPAREN .)


state 120

    (27) stmt -> NAME LBRACKET NUMBER RBRACKET EQUALS . expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . expr TIMES expr
    (21) expr -> . MINUS expr
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . NUMBER
    (24) expr -> . NAME
    (25) expr -> . MEMREF
    (26) expr -> . NAME LBRACKET NUMBER RBRACKET

    MINUS           shift and go to state 37
    LPAREN          shift and go to state 39
    NUMBER          shift and go to state 42
    NAME            shift and go to state 40
    MEMREF          shift and go to state 43

    expr                           shift and go to state 142

state 121

    (28) stmt -> NAME LBRACKET NUMBER RBRACKET ASSIGN_OP . expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . expr TIMES expr
    (21) expr -> . MINUS expr
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . NUMBER
    (24) expr -> . NAME
    (25) expr -> . MEMREF
    (26) expr -> . NAME LBRACKET NUMBER RBRACKET

    MINUS           shift and go to state 37
    LPAREN          shift and go to state 39
    NUMBER          shift and go to state 42
    NAME            shift and go to state 40
    MEMREF          shift and go to state 43

    expr                           shift and go to state 143

state 122

    (29) stmt -> WHILE NAME NE NAME COLON . BEGIN stmts END

    BEGIN           shift and go to state 144


state 123

    (30) stmt -> WHILE NAME NE NUMBER COLON . BEGIN stmts END

    BEGIN           shift and go to state 145


state 124

    (31) stmt -> WHILE NAME LT NAME COLON . BEGIN stmts END

    BEGIN           shift and go to state 146


state 125

    (32) stmt -> WHILE NAME LT NUMBER COLON . BEGIN stmts END

    BEGIN           shift and go to state 147


state 126

    (50) stmt -> WHILE NAME GT NAME COLON . BEGIN stmts END

    BEGIN           shift and go to state 148


state 127

    (51) stmt -> WHILE NAME GT NUMBER COLON . BEGIN stmts END

    BEGIN           shift and go to state 149


state 128

    (49) stmt -> WHILE cond COLON BEGIN stmts . END

    END             shift and go to state 150


state 129

    (38) cond -> NAME LT NAME .

    AND             reduce using rule 38 (cond -> NAME LT NAME .)
    OR              reduce using rule 38 (cond -> NAME LT NAME .)
    COLON           reduce using rule 38 (cond -> NAME LT NAME .)


state 130

    (40) cond -> NAME GT NAME .

    AND             reduce using rule 40 (cond -> NAME GT NAME .)
    OR              reduce using rule 40 (cond -> NAME GT NAME .)
    COLON           reduce using rule 40 (cond -> NAME GT NAME .)


state 131

    (48) stmt -> IF cond COLON BEGIN stmts . END

    END             shift and go to state 151


state 132

    (62) stmt -> IF NAME GT NAME COLON . BEGIN stmts END
    (66) stmt -> IF NAME GT NAME COLON . BEGIN stmts END ELSE COLON BEGIN stmts END

    BEGIN           shift and go to state 152


state 133

    (63) stmt -> IF NAME EQEQ NAME COLON . BEGIN stmts END

    BEGIN           shift and go to state 153


state 134

    (65) stmt -> IF NAME EQEQ NUMBER COLON . BEGIN stmts END

    BEGIN           shift and go to state 154


state 135

    (64) stmt -> IF NAME LT NAME COLON . BEGIN stmts END

    BEGIN           shift and go to state 155


state 136

    (53) stmt -> VAR NAME LBRACKET NUMBER RBRACKET .

    NAME            reduce using rule 53 (stmt -> VAR NAME LBRACKET NUMBER RBRACKET .)
    MEMREF          reduce using rule 53 (stmt -> VAR NAME LBRACKET NUMBER RBRACKET .)
    REGISTER        reduce using rule 53 (stmt -> VAR NAME LBRACKET NUMBER RBRACKET .)
    WHILE           reduce using rule 53 (stmt -> VAR NAME LBRACKET NUMBER RBRACKET .)
    IF              reduce using rule 53 (stmt -> VAR NAME LBRACKET NUMBER RBRACKET .)
    VAR             reduce using rule 53 (stmt -> VAR NAME LBRACKET NUMBER RBRACKET .)
    PROC            reduce using rule 53 (stmt -> VAR NAME LBRACKET NUMBER RBRACKET .)
    CALL            reduce using rule 53 (stmt -> VAR NAME LBRACKET NUMBER RBRACKET .)
    $end            reduce using rule 53 (stmt -> VAR NAME LBRACKET NUMBER RBRACKET .)
    END             reduce using rule 53 (stmt -> VAR NAME LBRACKET NUMBER RBRACKET .)


state 137

    (57) params -> NAME COMMA . params
    (55) params -> .
    (56) params -> . NAME
    (57) params -> . NAME COMMA params

    RPAREN          reduce using rule 55 (params -> .)
    NAME            shift and go to state 105

    params                         shift and go to state 156

state 138

    (54) stmt -> PROC NAME LPAREN params RPAREN . COLON BEGIN stmts END

    COLON           shift and go to state 157


state 139

    (58) stmt -> CALL NAME LPAREN args RPAREN .

    NAME            reduce using rule 58 (stmt -> CALL NAME LPAREN args RPAREN .)
    MEMREF          reduce using rule 58 (stmt -> CALL NAME LPAREN args RPAREN .)
    REGISTER        reduce using rule 58 (stmt -> CALL NAME LPAREN args RPAREN .)
    WHILE           reduce using rule 58 (stmt -> CALL NAME LPAREN args RPAREN .)
    IF              reduce using rule 58 (stmt -> CALL NAME LPAREN args RPAREN .)
    VAR             reduce using rule 58 (stmt -> CALL NAME LPAREN args RPAREN .)
    PROC            reduce using rule 58 (stmt -> CALL NAME LPAREN args RPAREN .)
    CALL            reduce using rule 58 (stmt -> CALL NAME LPAREN args RPAREN .)
    $end            reduce using rule 58 (stmt -> CALL NAME LPAREN args RPAREN .)
    END             reduce using rule 58 (stmt -> CALL NAME LPAREN args RPAREN .)


state 140

    (61) args -> expr COMMA . args
    (59) args -> .
    (60) args -> . expr
    (61) args -> . expr COMMA args
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . expr TIMES expr
    (21) expr -> . MINUS expr
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . NUMBER
    (24) expr -> . NAME
    (25) expr -> . MEMREF
    (26) expr -> . NAME LBRACKET NUMBER RBRACKET

    RPAREN          reduce using rule 59 (args -> .)
    MINUS           shift and go to state 37
    LPAREN          shift and go to state 39
    NUMBER          shift and go to state 42
    NAME            shift and go to state 40
    MEMREF          shift and go to state 43

    expr                           shift and go to state 108
    args                           shift and go to state 158

state 141

    (26) expr -> NAME LBRACKET NUMBER RBRACKET .

    PLUS            reduce using rule 26 (expr -> NAME LBRACKET NUMBER RBRACKET .)
    MINUS           reduce using rule 26 (expr -> NAME LBRACKET NUMBER RBRACKET .)
    TIMES           reduce using rule 26 (expr -> NAME LBRACKET NUMBER RBRACKET .)
    NAME            reduce using rule 26 (expr -> NAME LBRACKET NUMBER RBRACKET .)
    MEMREF          reduce using rule 26 (expr -> NAME LBRACKET NUMBER RBRACKET .)
    REGISTER        reduce using rule 26 (expr -> NAME LBRACKET NUMBER RBRACKET .)
    WHILE           reduce using rule 26 (expr -> NAME LBRACKET NUMBER RBRACKET .)
    IF              reduce using rule 26 (expr -> NAME LBRACKET NUMBER RBRACKET .)
    VAR             reduce using rule 26 (expr -> NAME LBRACKET NUMBER RBRACKET .)
    PROC            reduce using rule 26 (expr -> NAME LBRACKET NUMBER RBRACKET .)
    CALL            reduce using rule 26 (expr -> NAME LBRACKET NUMBER RBRACKET .)
    $end            reduce using rule 26 (expr -> NAME LBRACKET NUMBER RBRACKET .)
    END             reduce using rule 26 (expr -> NAME LBRACKET NUMBER RBRACKET .)
    RPAREN          reduce using rule 26 (expr -> NAME LBRACKET NUMBER RBRACKET .)
    COMMA           reduce using rule 26 (expr -> NAME LBRACKET NUMBER RBRACKET .)


state 142

    (27) stmt -> NAME LBRACKET NUMBER RBRACKET EQUALS expr .
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (20) expr -> expr . TIMES expr

    NAME            reduce using rule 27 (stmt -> NAME LBRACKET NUMBER RBRACKET EQUALS expr .)
    MEMREF          reduce using rule 27 (stmt -> NAME LBRACKET NUMBER RBRACKET EQUALS expr .)
    REGISTER        reduce using rule 27 (stmt -> NAME LBRACKET NUMBER RBRACKET EQUALS expr .)
    WHILE           reduce using rule 27 (stmt -> NAME LBRACKET NUMBER RBRACKET EQUALS expr .)
    IF              reduce using rule 27 (stmt -> NAME LBRACKET NUMBER RBRACKET EQUALS expr .)
    VAR             reduce using rule 27 (stmt -> NAME LBRACKET NUMBER RBRACKET EQUALS expr .)
    PROC            reduce using rule 27 (stmt -> NAME LBRACKET NUMBER RBRACKET EQUALS expr .)
    CALL            reduce using rule 27 (stmt -> NAME LBRACKET NUMBER RBRACKET EQUALS expr .)
    $end            reduce using rule 27 (stmt -> NAME LBRACKET NUMBER RBRACKET EQUALS expr .)
    END             reduce using rule 27 (stmt -> NAME LBRACKET NUMBER RBRACKET EQUALS expr .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    TIMES           shift and go to state 75


state 143

    (28) stmt -> NAME LBRACKET NUMBER RBRACKET ASSIGN_OP expr .
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (20) expr -> expr . TIMES expr

    NAME            reduce using rule 28 (stmt -> NAME LBRACKET NUMBER RBRACKET ASSIGN_OP expr .)
    MEMREF          reduce using rule 28 (stmt -> NAME LBRACKET NUMBER RBRACKET ASSIGN_OP expr .)
    REGISTER        reduce using rule 28 (stmt -> NAME LBRACKET NUMBER RBRACKET ASSIGN_OP expr .)
    WHILE           reduce using rule 28 (stmt -> NAME LBRACKET NUMBER RBRACKET ASSIGN_OP expr .)
    IF              reduce using rule 28 (stmt -> NAME LBRACKET NUMBER RBRACKET ASSIGN_OP expr .)
    VAR             reduce using rule 28 (stmt -> NAME LBRACKET NUMBER RBRACKET ASSIGN_OP expr .)
    PROC            reduce using rule 28 (stmt -> NAME LBRACKET NUMBER RBRACKET ASSIGN_OP expr .)
    CALL            reduce using rule 28 (stmt -> NAME LBRACKET NUMBER RBRACKET ASSIGN_OP expr .)
    $end            reduce using rule 28 (stmt -> NAME LBRACKET NUMBER RBRACKET ASSIGN_OP expr .)
    END             reduce using rule 28 (stmt -> NAME LBRACKET NUMBER RBRACKET ASSIGN_OP expr .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    TIMES           shift and go to state 75


state 144

    (29) stmt -> WHILE NAME NE NAME COLON BEGIN . stmts END
    (2) stmts -> . stmt stmts
    (3) stmts -> .
    (4) stmt -> . NAME EQUALS MEMREF
    (5) stmt -> . MEMREF EQUALS NAME
    (6) stmt -> . NAME EQUALS NUMBER
    (7) stmt -> . NAME EQUALS NAME
    (8) stmt -> . NAME EQUALS NAME PLUS NAME
    (9) stmt -> . NAME EQUALS NAME MINUS NAME
    (10) stmt -> . NAME EQUALS NAME PLUS NUMBER
    (11) stmt -> . NAME EQUALS NAME MINUS NUMBER
    (12) stmt -> . NAME EQUALS NAME TIMES NAME
    (13) stmt -> . NAME EQUALS NAME TIMES NUMBER
    (14) stmt -> . NAME EQUALS expr
    (15) stmt -> . NAME ASSIGN_OP expr
    (16) stmt -> . REGISTER EQUALS expr
    (17) stmt -> . REGISTER ASSIGN_OP expr
    (27) stmt -> . NAME LBRACKET NUMBER RBRACKET EQUALS expr
    (28) stmt -> . NAME LBRACKET NUMBER RBRACKET ASSIGN_OP expr
    (29) stmt -> . WHILE NAME NE NAME COLON BEGIN stmts END
    (30) stmt -> . WHILE NAME NE NUMBER COLON BEGIN stmts END
    (31) stmt -> . WHILE NAME LT NAME COLON BEGIN stmts END
    (32) stmt -> . WHILE NAME LT NUMBER COLON BEGIN stmts END
    (48) stmt -> . IF cond COLON BEGIN stmts END
    (49) stmt -> . WHILE cond COLON BEGIN stmts END
    (50) stmt -> . WHILE NAME GT NAME COLON BEGIN stmts END
    (51) stmt -> . WHILE NAME GT NUMBER COLON BEGIN stmts END
    (52) stmt -> . VAR NAME
    (53) stmt -> . VAR NAME LBRACKET NUMBER RBRACKET
    (54) stmt -> . PROC NAME LPAREN params RPAREN COLON BEGIN stmts END
    (58) stmt -> . CALL NAME LPAREN args RPAREN
    (62) stmt -> . IF NAME GT NAME COLON BEGIN stmts END
    (63) stmt -> . IF NAME EQEQ NAME COLON BEGIN stmts END
    (64) stmt -> . IF NAME LT NAME COLON BEGIN stmts END
    (65) stmt -> . IF NAME EQEQ NUMBER COLON BEGIN stmts END
    (66) stmt -> . IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END
    (67) stmt -> . NAME asm_args

    END             reduce using rule 3 (stmts -> .)
    NAME            shift and go to state 4
    MEMREF          shift and go to state 5
    REGISTER        shift and go to state 6
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    VAR             shift and go to state 9
    PROC            shift and go to state 10
    CALL            shift and go to state 11

    stmts                          shift and go to state 159
    stmt                           shift and go to state 3

state 145

    (30) stmt -> WHILE NAME NE NUMBER COLON BEGIN . stmts END
    (2) stmts -> . stmt stmts
    (3) stmts -> .
    (4) stmt -> . NAME EQUALS MEMREF
    (5) stmt -> . MEMREF EQUALS NAME
    (6) stmt -> . NAME EQUALS NUMBER
    (7) stmt -> . NAME EQUALS NAME
    (8) stmt -> . NAME EQUALS NAME PLUS NAME
    (9) stmt -> . NAME EQUALS NAME MINUS NAME
    (10) stmt -> . NAME EQUALS NAME PLUS NUMBER
    (11) stmt -> . NAME EQUALS NAME MINUS NUMBER
    (12) stmt -> . NAME EQUALS NAME TIMES NAME
    (13) stmt -> . NAME EQUALS NAME TIMES NUMBER
    (14) stmt -> . NAME EQUALS expr
    (15) stmt -> . NAME ASSIGN_OP expr
    (16) stmt -> . REGISTER EQUALS expr
    (17) stmt -> . REGISTER ASSIGN_OP expr
    (27) stmt -> . NAME LBRACKET NUMBER RBRACKET EQUALS expr
    (28) stmt -> . NAME LBRACKET NUMBER RBRACKET ASSIGN_OP expr
    (29) stmt -> . WHILE NAME NE NAME COLON BEGIN stmts END
    (30) stmt -> . WHILE NAME NE NUMBER COLON BEGIN stmts END
    (31) stmt -> . WHILE NAME LT NAME COLON BEGIN stmts END
    (32) stmt -> . WHILE NAME LT NUMBER COLON BEGIN stmts END
    (48) stmt -> . IF cond COLON BEGIN stmts END
    (49) stmt -> . WHILE cond COLON BEGIN stmts END
    (50) stmt -> . WHILE NAME GT NAME COLON BEGIN stmts END
    (51) stmt -> . WHILE NAME GT NUMBER COLON BEGIN stmts END
    (52) stmt -> . VAR NAME
    (53) stmt -> . VAR NAME LBRACKET NUMBER RBRACKET
    (54) stmt -> . PROC NAME LPAREN params RPAREN COLON BEGIN stmts END
    (58) stmt -> . CALL NAME LPAREN args RPAREN
    (62) stmt -> . IF NAME GT NAME COLON BEGIN stmts END
    (63) stmt -> . IF NAME EQEQ NAME COLON BEGIN stmts END
    (64) stmt -> . IF NAME LT NAME COLON BEGIN stmts END
    (65) stmt -> . IF NAME EQEQ NUMBER COLON BEGIN stmts END
    (66) stmt -> . IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END
    (67) stmt -> . NAME asm_args

    END             reduce using rule 3 (stmts -> .)
    NAME            shift and go to state 4
    MEMREF          shift and go to state 5
    REGISTER        shift and go to state 6
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    VAR             shift and go to state 9
    PROC            shift and go to state 10
    CALL            shift and go to state 11

    stmts                          shift and go to state 160
    stmt                           shift and go to state 3

state 146

    (31) stmt -> WHILE NAME LT NAME COLON BEGIN . stmts END
    (2) stmts -> . stmt stmts
    (3) stmts -> .
    (4) stmt -> . NAME EQUALS MEMREF
    (5) stmt -> . MEMREF EQUALS NAME
    (6) stmt -> . NAME EQUALS NUMBER
    (7) stmt -> . NAME EQUALS NAME
    (8) stmt -> . NAME EQUALS NAME PLUS NAME
    (9) stmt -> . NAME EQUALS NAME MINUS NAME
    (10) stmt -> . NAME EQUALS NAME PLUS NUMBER
    (11) stmt -> . NAME EQUALS NAME MINUS NUMBER
    (12) stmt -> . NAME EQUALS NAME TIMES NAME
    (13) stmt -> . NAME EQUALS NAME TIMES NUMBER
    (14) stmt -> . NAME EQUALS expr
    (15) stmt -> . NAME ASSIGN_OP expr
    (16) stmt -> . REGISTER EQUALS expr
    (17) stmt -> . REGISTER ASSIGN_OP expr
    (27) stmt -> . NAME LBRACKET NUMBER RBRACKET EQUALS expr
    (28) stmt -> . NAME LBRACKET NUMBER RBRACKET ASSIGN_OP expr
    (29) stmt -> . WHILE NAME NE NAME COLON BEGIN stmts END
    (30) stmt -> . WHILE NAME NE NUMBER COLON BEGIN stmts END
    (31) stmt -> . WHILE NAME LT NAME COLON BEGIN stmts END
    (32) stmt -> . WHILE NAME LT NUMBER COLON BEGIN stmts END
    (48) stmt -> . IF cond COLON BEGIN stmts END
    (49) stmt -> . WHILE cond COLON BEGIN stmts END
    (50) stmt -> . WHILE NAME GT NAME COLON BEGIN stmts END
    (51) stmt -> . WHILE NAME GT NUMBER COLON BEGIN stmts END
    (52) stmt -> . VAR NAME
    (53) stmt -> . VAR NAME LBRACKET NUMBER RBRACKET
    (54) stmt -> . PROC NAME LPAREN params RPAREN COLON BEGIN stmts END
    (58) stmt -> . CALL NAME LPAREN args RPAREN
    (62) stmt -> . IF NAME GT NAME COLON BEGIN stmts END
    (63) stmt -> . IF NAME EQEQ NAME COLON BEGIN stmts END
    (64) stmt -> . IF NAME LT NAME COLON BEGIN stmts END
    (65) stmt -> . IF NAME EQEQ NUMBER COLON BEGIN stmts END
    (66) stmt -> . IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END
    (67) stmt -> . NAME asm_args

    END             reduce using rule 3 (stmts -> .)
    NAME            shift and go to state 4
    MEMREF          shift and go to state 5
    REGISTER        shift and go to state 6
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    VAR             shift and go to state 9
    PROC            shift and go to state 10
    CALL            shift and go to state 11

    stmts                          shift and go to state 161
    stmt                           shift and go to state 3

state 147

    (32) stmt -> WHILE NAME LT NUMBER COLON BEGIN . stmts END
    (2) stmts -> . stmt stmts
    (3) stmts -> .
    (4) stmt -> . NAME EQUALS MEMREF
    (5) stmt -> . MEMREF EQUALS NAME
    (6) stmt -> . NAME EQUALS NUMBER
    (7) stmt -> . NAME EQUALS NAME
    (8) stmt -> . NAME EQUALS NAME PLUS NAME
    (9) stmt -> . NAME EQUALS NAME MINUS NAME
    (10) stmt -> . NAME EQUALS NAME PLUS NUMBER
    (11) stmt -> . NAME EQUALS NAME MINUS NUMBER
    (12) stmt -> . NAME EQUALS NAME TIMES NAME
    (13) stmt -> . NAME EQUALS NAME TIMES NUMBER
    (14) stmt -> . NAME EQUALS expr
    (15) stmt -> . NAME ASSIGN_OP expr
    (16) stmt -> . REGISTER EQUALS expr
    (17) stmt -> . REGISTER ASSIGN_OP expr
    (27) stmt -> . NAME LBRACKET NUMBER RBRACKET EQUALS expr
    (28) stmt -> . NAME LBRACKET NUMBER RBRACKET ASSIGN_OP expr
    (29) stmt -> . WHILE NAME NE NAME COLON BEGIN stmts END
    (30) stmt -> . WHILE NAME NE NUMBER COLON BEGIN stmts END
    (31) stmt -> . WHILE NAME LT NAME COLON BEGIN stmts END
    (32) stmt -> . WHILE NAME LT NUMBER COLON BEGIN stmts END
    (48) stmt -> . IF cond COLON BEGIN stmts END
    (49) stmt -> . WHILE cond COLON BEGIN stmts END
    (50) stmt -> . WHILE NAME GT NAME COLON BEGIN stmts END
    (51) stmt -> . WHILE NAME GT NUMBER COLON BEGIN stmts END
    (52) stmt -> . VAR NAME
    (53) stmt -> . VAR NAME LBRACKET NUMBER RBRACKET
    (54) stmt -> . PROC NAME LPAREN params RPAREN COLON BEGIN stmts END
    (58) stmt -> . CALL NAME LPAREN args RPAREN
    (62) stmt -> . IF NAME GT NAME COLON BEGIN stmts END
    (63) stmt -> . IF NAME EQEQ NAME COLON BEGIN stmts END
    (64) stmt -> . IF NAME LT NAME COLON BEGIN stmts END
    (65) stmt -> . IF NAME EQEQ NUMBER COLON BEGIN stmts END
    (66) stmt -> . IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END
    (67) stmt -> . NAME asm_args

    END             reduce using rule 3 (stmts -> .)
    NAME            shift and go to state 4
    MEMREF          shift and go to state 5
    REGISTER        shift and go to state 6
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    VAR             shift and go to state 9
    PROC            shift and go to state 10
    CALL            shift and go to state 11

    stmts                          shift and go to state 162
    stmt                           shift and go to state 3

state 148

    (50) stmt -> WHILE NAME GT NAME COLON BEGIN . stmts END
    (2) stmts -> . stmt stmts
    (3) stmts -> .
    (4) stmt -> . NAME EQUALS MEMREF
    (5) stmt -> . MEMREF EQUALS NAME
    (6) stmt -> . NAME EQUALS NUMBER
    (7) stmt -> . NAME EQUALS NAME
    (8) stmt -> . NAME EQUALS NAME PLUS NAME
    (9) stmt -> . NAME EQUALS NAME MINUS NAME
    (10) stmt -> . NAME EQUALS NAME PLUS NUMBER
    (11) stmt -> . NAME EQUALS NAME MINUS NUMBER
    (12) stmt -> . NAME EQUALS NAME TIMES NAME
    (13) stmt -> . NAME EQUALS NAME TIMES NUMBER
    (14) stmt -> . NAME EQUALS expr
    (15) stmt -> . NAME ASSIGN_OP expr
    (16) stmt -> . REGISTER EQUALS expr
    (17) stmt -> . REGISTER ASSIGN_OP expr
    (27) stmt -> . NAME LBRACKET NUMBER RBRACKET EQUALS expr
    (28) stmt -> . NAME LBRACKET NUMBER RBRACKET ASSIGN_OP expr
    (29) stmt -> . WHILE NAME NE NAME COLON BEGIN stmts END
    (30) stmt -> . WHILE NAME NE NUMBER COLON BEGIN stmts END
    (31) stmt -> . WHILE NAME LT NAME COLON BEGIN stmts END
    (32) stmt -> . WHILE NAME LT NUMBER COLON BEGIN stmts END
    (48) stmt -> . IF cond COLON BEGIN stmts END
    (49) stmt -> . WHILE cond COLON BEGIN stmts END
    (50) stmt -> . WHILE NAME GT NAME COLON BEGIN stmts END
    (51) stmt -> . WHILE NAME GT NUMBER COLON BEGIN stmts END
    (52) stmt -> . VAR NAME
    (53) stmt -> . VAR NAME LBRACKET NUMBER RBRACKET
    (54) stmt -> . PROC NAME LPAREN params RPAREN COLON BEGIN stmts END
    (58) stmt -> . CALL NAME LPAREN args RPAREN
    (62) stmt -> . IF NAME GT NAME COLON BEGIN stmts END
    (63) stmt -> . IF NAME EQEQ NAME COLON BEGIN stmts END
    (64) stmt -> . IF NAME LT NAME COLON BEGIN stmts END
    (65) stmt -> . IF NAME EQEQ NUMBER COLON BEGIN stmts END
    (66) stmt -> . IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END
    (67) stmt -> . NAME asm_args

    END             reduce using rule 3 (stmts -> .)
    NAME            shift and go to state 4
    MEMREF          shift and go to state 5
    REGISTER        shift and go to state 6
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    VAR             shift and go to state 9
    PROC            shift and go to state 10
    CALL            shift and go to state 11

    stmts                          shift and go to state 163
    stmt                           shift and go to state 3

state 149

    (51) stmt -> WHILE NAME GT NUMBER COLON BEGIN . stmts END
    (2) stmts -> . stmt stmts
    (3) stmts -> .
    (4) stmt -> . NAME EQUALS MEMREF
    (5) stmt -> . MEMREF EQUALS NAME
    (6) stmt -> . NAME EQUALS NUMBER
    (7) stmt -> . NAME EQUALS NAME
    (8) stmt -> . NAME EQUALS NAME PLUS NAME
    (9) stmt -> . NAME EQUALS NAME MINUS NAME
    (10) stmt -> . NAME EQUALS NAME PLUS NUMBER
    (11) stmt -> . NAME EQUALS NAME MINUS NUMBER
    (12) stmt -> . NAME EQUALS NAME TIMES NAME
    (13) stmt -> . NAME EQUALS NAME TIMES NUMBER
    (14) stmt -> . NAME EQUALS expr
    (15) stmt -> . NAME ASSIGN_OP expr
    (16) stmt -> . REGISTER EQUALS expr
    (17) stmt -> . REGISTER ASSIGN_OP expr
    (27) stmt -> . NAME LBRACKET NUMBER RBRACKET EQUALS expr
    (28) stmt -> . NAME LBRACKET NUMBER RBRACKET ASSIGN_OP expr
    (29) stmt -> . WHILE NAME NE NAME COLON BEGIN stmts END
    (30) stmt -> . WHILE NAME NE NUMBER COLON BEGIN stmts END
    (31) stmt -> . WHILE NAME LT NAME COLON BEGIN stmts END
    (32) stmt -> . WHILE NAME LT NUMBER COLON BEGIN stmts END
    (48) stmt -> . IF cond COLON BEGIN stmts END
    (49) stmt -> . WHILE cond COLON BEGIN stmts END
    (50) stmt -> . WHILE NAME GT NAME COLON BEGIN stmts END
    (51) stmt -> . WHILE NAME GT NUMBER COLON BEGIN stmts END
    (52) stmt -> . VAR NAME
    (53) stmt -> . VAR NAME LBRACKET NUMBER RBRACKET
    (54) stmt -> . PROC NAME LPAREN params RPAREN COLON BEGIN stmts END
    (58) stmt -> . CALL NAME LPAREN args RPAREN
    (62) stmt -> . IF NAME GT NAME COLON BEGIN stmts END
    (63) stmt -> . IF NAME EQEQ NAME COLON BEGIN stmts END
    (64) stmt -> . IF NAME LT NAME COLON BEGIN stmts END
    (65) stmt -> . IF NAME EQEQ NUMBER COLON BEGIN stmts END
    (66) stmt -> . IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END
    (67) stmt -> . NAME asm_args

    END             reduce using rule 3 (stmts -> .)
    NAME            shift and go to state 4
    MEMREF          shift and go to state 5
    REGISTER        shift and go to state 6
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    VAR             shift and go to state 9
    PROC            shift and go to state 10
    CALL            shift and go to state 11

    stmts                          shift and go to state 164
    stmt                           shift and go to state 3

state 150

    (49) stmt -> WHILE cond COLON BEGIN stmts END .

    NAME            reduce using rule 49 (stmt -> WHILE cond COLON BEGIN stmts END .)
    MEMREF          reduce using rule 49 (stmt -> WHILE cond COLON BEGIN stmts END .)
    REGISTER        reduce using rule 49 (stmt -> WHILE cond COLON BEGIN stmts END .)
    WHILE           reduce using rule 49 (stmt -> WHILE cond COLON BEGIN stmts END .)
    IF              reduce using rule 49 (stmt -> WHILE cond COLON BEGIN stmts END .)
    VAR             reduce using rule 49 (stmt -> WHILE cond COLON BEGIN stmts END .)
    PROC            reduce using rule 49 (stmt -> WHILE cond COLON BEGIN stmts END .)
    CALL            reduce using rule 49 (stmt -> WHILE cond COLON BEGIN stmts END .)
    $end            reduce using rule 49 (stmt -> WHILE cond COLON BEGIN stmts END .)
    END             reduce using rule 49 (stmt -> WHILE cond COLON BEGIN stmts END .)


state 151

    (48) stmt -> IF cond COLON BEGIN stmts END .

    NAME            reduce using rule 48 (stmt -> IF cond COLON BEGIN stmts END .)
    MEMREF          reduce using rule 48 (stmt -> IF cond COLON BEGIN stmts END .)
    REGISTER        reduce using rule 48 (stmt -> IF cond COLON BEGIN stmts END .)
    WHILE           reduce using rule 48 (stmt -> IF cond COLON BEGIN stmts END .)
    IF              reduce using rule 48 (stmt -> IF cond COLON BEGIN stmts END .)
    VAR             reduce using rule 48 (stmt -> IF cond COLON BEGIN stmts END .)
    PROC            reduce using rule 48 (stmt -> IF cond COLON BEGIN stmts END .)
    CALL            reduce using rule 48 (stmt -> IF cond COLON BEGIN stmts END .)
    $end            reduce using rule 48 (stmt -> IF cond COLON BEGIN stmts END .)
    END             reduce using rule 48 (stmt -> IF cond COLON BEGIN stmts END .)


state 152

    (62) stmt -> IF NAME GT NAME COLON BEGIN . stmts END
    (66) stmt -> IF NAME GT NAME COLON BEGIN . stmts END ELSE COLON BEGIN stmts END
    (2) stmts -> . stmt stmts
    (3) stmts -> .
    (4) stmt -> . NAME EQUALS MEMREF
    (5) stmt -> . MEMREF EQUALS NAME
    (6) stmt -> . NAME EQUALS NUMBER
    (7) stmt -> . NAME EQUALS NAME
    (8) stmt -> . NAME EQUALS NAME PLUS NAME
    (9) stmt -> . NAME EQUALS NAME MINUS NAME
    (10) stmt -> . NAME EQUALS NAME PLUS NUMBER
    (11) stmt -> . NAME EQUALS NAME MINUS NUMBER
    (12) stmt -> . NAME EQUALS NAME TIMES NAME
    (13) stmt -> . NAME EQUALS NAME TIMES NUMBER
    (14) stmt -> . NAME EQUALS expr
    (15) stmt -> . NAME ASSIGN_OP expr
    (16) stmt -> . REGISTER EQUALS expr
    (17) stmt -> . REGISTER ASSIGN_OP expr
    (27) stmt -> . NAME LBRACKET NUMBER RBRACKET EQUALS expr
    (28) stmt -> . NAME LBRACKET NUMBER RBRACKET ASSIGN_OP expr
    (29) stmt -> . WHILE NAME NE NAME COLON BEGIN stmts END
    (30) stmt -> . WHILE NAME NE NUMBER COLON BEGIN stmts END
    (31) stmt -> . WHILE NAME LT NAME COLON BEGIN stmts END
    (32) stmt -> . WHILE NAME LT NUMBER COLON BEGIN stmts END
    (48) stmt -> . IF cond COLON BEGIN stmts END
    (49) stmt -> . WHILE cond COLON BEGIN stmts END
    (50) stmt -> . WHILE NAME GT NAME COLON BEGIN stmts END
    (51) stmt -> . WHILE NAME GT NUMBER COLON BEGIN stmts END
    (52) stmt -> . VAR NAME
    (53) stmt -> . VAR NAME LBRACKET NUMBER RBRACKET
    (54) stmt -> . PROC NAME LPAREN params RPAREN COLON BEGIN stmts END
    (58) stmt -> . CALL NAME LPAREN args RPAREN
    (62) stmt -> . IF NAME GT NAME COLON BEGIN stmts END
    (63) stmt -> . IF NAME EQEQ NAME COLON BEGIN stmts END
    (64) stmt -> . IF NAME LT NAME COLON BEGIN stmts END
    (65) stmt -> . IF NAME EQEQ NUMBER COLON BEGIN stmts END
    (66) stmt -> . IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END
    (67) stmt -> . NAME asm_args

    END             reduce using rule 3 (stmts -> .)
    NAME            shift and go to state 4
    MEMREF          shift and go to state 5
    REGISTER        shift and go to state 6
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    VAR             shift and go to state 9
    PROC            shift and go to state 10
    CALL            shift and go to state 11

    stmts                          shift and go to state 165
    stmt                           shift and go to state 3

state 153

    (63) stmt -> IF NAME EQEQ NAME COLON BEGIN . stmts END
    (2) stmts -> . stmt stmts
    (3) stmts -> .
    (4) stmt -> . NAME EQUALS MEMREF
    (5) stmt -> . MEMREF EQUALS NAME
    (6) stmt -> . NAME EQUALS NUMBER
    (7) stmt -> . NAME EQUALS NAME
    (8) stmt -> . NAME EQUALS NAME PLUS NAME
    (9) stmt -> . NAME EQUALS NAME MINUS NAME
    (10) stmt -> . NAME EQUALS NAME PLUS NUMBER
    (11) stmt -> . NAME EQUALS NAME MINUS NUMBER
    (12) stmt -> . NAME EQUALS NAME TIMES NAME
    (13) stmt -> . NAME EQUALS NAME TIMES NUMBER
    (14) stmt -> . NAME EQUALS expr
    (15) stmt -> . NAME ASSIGN_OP expr
    (16) stmt -> . REGISTER EQUALS expr
    (17) stmt -> . REGISTER ASSIGN_OP expr
    (27) stmt -> . NAME LBRACKET NUMBER RBRACKET EQUALS expr
    (28) stmt -> . NAME LBRACKET NUMBER RBRACKET ASSIGN_OP expr
    (29) stmt -> . WHILE NAME NE NAME COLON BEGIN stmts END
    (30) stmt -> . WHILE NAME NE NUMBER COLON BEGIN stmts END
    (31) stmt -> . WHILE NAME LT NAME COLON BEGIN stmts END
    (32) stmt -> . WHILE NAME LT NUMBER COLON BEGIN stmts END
    (48) stmt -> . IF cond COLON BEGIN stmts END
    (49) stmt -> . WHILE cond COLON BEGIN stmts END
    (50) stmt -> . WHILE NAME GT NAME COLON BEGIN stmts END
    (51) stmt -> . WHILE NAME GT NUMBER COLON BEGIN stmts END
    (52) stmt -> . VAR NAME
    (53) stmt -> . VAR NAME LBRACKET NUMBER RBRACKET
    (54) stmt -> . PROC NAME LPAREN params RPAREN COLON BEGIN stmts END
    (58) stmt -> . CALL NAME LPAREN args RPAREN
    (62) stmt -> . IF NAME GT NAME COLON BEGIN stmts END
    (63) stmt -> . IF NAME EQEQ NAME COLON BEGIN stmts END
    (64) stmt -> . IF NAME LT NAME COLON BEGIN stmts END
    (65) stmt -> . IF NAME EQEQ NUMBER COLON BEGIN stmts END
    (66) stmt -> . IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END
    (67) stmt -> . NAME asm_args

    END             reduce using rule 3 (stmts -> .)
    NAME            shift and go to state 4
    MEMREF          shift and go to state 5
    REGISTER        shift and go to state 6
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    VAR             shift and go to state 9
    PROC            shift and go to state 10
    CALL            shift and go to state 11

    stmts                          shift and go to state 166
    stmt                           shift and go to state 3

state 154

    (65) stmt -> IF NAME EQEQ NUMBER COLON BEGIN . stmts END
    (2) stmts -> . stmt stmts
    (3) stmts -> .
    (4) stmt -> . NAME EQUALS MEMREF
    (5) stmt -> . MEMREF EQUALS NAME
    (6) stmt -> . NAME EQUALS NUMBER
    (7) stmt -> . NAME EQUALS NAME
    (8) stmt -> . NAME EQUALS NAME PLUS NAME
    (9) stmt -> . NAME EQUALS NAME MINUS NAME
    (10) stmt -> . NAME EQUALS NAME PLUS NUMBER
    (11) stmt -> . NAME EQUALS NAME MINUS NUMBER
    (12) stmt -> . NAME EQUALS NAME TIMES NAME
    (13) stmt -> . NAME EQUALS NAME TIMES NUMBER
    (14) stmt -> . NAME EQUALS expr
    (15) stmt -> . NAME ASSIGN_OP expr
    (16) stmt -> . REGISTER EQUALS expr
    (17) stmt -> . REGISTER ASSIGN_OP expr
    (27) stmt -> . NAME LBRACKET NUMBER RBRACKET EQUALS expr
    (28) stmt -> . NAME LBRACKET NUMBER RBRACKET ASSIGN_OP expr
    (29) stmt -> . WHILE NAME NE NAME COLON BEGIN stmts END
    (30) stmt -> . WHILE NAME NE NUMBER COLON BEGIN stmts END
    (31) stmt -> . WHILE NAME LT NAME COLON BEGIN stmts END
    (32) stmt -> . WHILE NAME LT NUMBER COLON BEGIN stmts END
    (48) stmt -> . IF cond COLON BEGIN stmts END
    (49) stmt -> . WHILE cond COLON BEGIN stmts END
    (50) stmt -> . WHILE NAME GT NAME COLON BEGIN stmts END
    (51) stmt -> . WHILE NAME GT NUMBER COLON BEGIN stmts END
    (52) stmt -> . VAR NAME
    (53) stmt -> . VAR NAME LBRACKET NUMBER RBRACKET
    (54) stmt -> . PROC NAME LPAREN params RPAREN COLON BEGIN stmts END
    (58) stmt -> . CALL NAME LPAREN args RPAREN
    (62) stmt -> . IF NAME GT NAME COLON BEGIN stmts END
    (63) stmt -> . IF NAME EQEQ NAME COLON BEGIN stmts END
    (64) stmt -> . IF NAME LT NAME COLON BEGIN stmts END
    (65) stmt -> . IF NAME EQEQ NUMBER COLON BEGIN stmts END
    (66) stmt -> . IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END
    (67) stmt -> . NAME asm_args

    END             reduce using rule 3 (stmts -> .)
    NAME            shift and go to state 4
    MEMREF          shift and go to state 5
    REGISTER        shift and go to state 6
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    VAR             shift and go to state 9
    PROC            shift and go to state 10
    CALL            shift and go to state 11

    stmts                          shift and go to state 167
    stmt                           shift and go to state 3

state 155

    (64) stmt -> IF NAME LT NAME COLON BEGIN . stmts END
    (2) stmts -> . stmt stmts
    (3) stmts -> .
    (4) stmt -> . NAME EQUALS MEMREF
    (5) stmt -> . MEMREF EQUALS NAME
    (6) stmt -> . NAME EQUALS NUMBER
    (7) stmt -> . NAME EQUALS NAME
    (8) stmt -> . NAME EQUALS NAME PLUS NAME
    (9) stmt -> . NAME EQUALS NAME MINUS NAME
    (10) stmt -> . NAME EQUALS NAME PLUS NUMBER
    (11) stmt -> . NAME EQUALS NAME MINUS NUMBER
    (12) stmt -> . NAME EQUALS NAME TIMES NAME
    (13) stmt -> . NAME EQUALS NAME TIMES NUMBER
    (14) stmt -> . NAME EQUALS expr
    (15) stmt -> . NAME ASSIGN_OP expr
    (16) stmt -> . REGISTER EQUALS expr
    (17) stmt -> . REGISTER ASSIGN_OP expr
    (27) stmt -> . NAME LBRACKET NUMBER RBRACKET EQUALS expr
    (28) stmt -> . NAME LBRACKET NUMBER RBRACKET ASSIGN_OP expr
    (29) stmt -> . WHILE NAME NE NAME COLON BEGIN stmts END
    (30) stmt -> . WHILE NAME NE NUMBER COLON BEGIN stmts END
    (31) stmt -> . WHILE NAME LT NAME COLON BEGIN stmts END
    (32) stmt -> . WHILE NAME LT NUMBER COLON BEGIN stmts END
    (48) stmt -> . IF cond COLON BEGIN stmts END
    (49) stmt -> . WHILE cond COLON BEGIN stmts END
    (50) stmt -> . WHILE NAME GT NAME COLON BEGIN stmts END
    (51) stmt -> . WHILE NAME GT NUMBER COLON BEGIN stmts END
    (52) stmt -> . VAR NAME
    (53) stmt -> . VAR NAME LBRACKET NUMBER RBRACKET
    (54) stmt -> . PROC NAME LPAREN params RPAREN COLON BEGIN stmts END
    (58) stmt -> . CALL NAME LPAREN args RPAREN
    (62) stmt -> . IF NAME GT NAME COLON BEGIN stmts END
    (63) stmt -> . IF NAME EQEQ NAME COLON BEGIN stmts END
    (64) stmt -> . IF NAME LT NAME COLON BEGIN stmts END
    (65) stmt -> . IF NAME EQEQ NUMBER COLON BEGIN stmts END
    (66) stmt -> . IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END
    (67) stmt -> . NAME asm_args

    END             reduce using rule 3 (stmts -> .)
    NAME            shift and go to state 4
    MEMREF          shift and go to state 5
    REGISTER        shift and go to state 6
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    VAR             shift and go to state 9
    PROC            shift and go to state 10
    CALL            shift and go to state 11

    stmts                          shift and go to state 168
    stmt                           shift and go to state 3

state 156

    (57) params -> NAME COMMA params .

    RPAREN          reduce using rule 57 (params -> NAME COMMA params .)


state 157

    (54) stmt -> PROC NAME LPAREN params RPAREN COLON . BEGIN stmts END

    BEGIN           shift and go to state 169


state 158

    (61) args -> expr COMMA args .

    RPAREN          reduce using rule 61 (args -> expr COMMA args .)


state 159

    (29) stmt -> WHILE NAME NE NAME COLON BEGIN stmts . END

    END             shift and go to state 170


state 160

    (30) stmt -> WHILE NAME NE NUMBER COLON BEGIN stmts . END

    END             shift and go to state 171


state 161

    (31) stmt -> WHILE NAME LT NAME COLON BEGIN stmts . END

    END             shift and go to state 172


state 162

    (32) stmt -> WHILE NAME LT NUMBER COLON BEGIN stmts . END

    END             shift and go to state 173


state 163

    (50) stmt -> WHILE NAME GT NAME COLON BEGIN stmts . END

    END             shift and go to state 174


state 164

    (51) stmt -> WHILE NAME GT NUMBER COLON BEGIN stmts . END

    END             shift and go to state 175


state 165

    (62) stmt -> IF NAME GT NAME COLON BEGIN stmts . END
    (66) stmt -> IF NAME GT NAME COLON BEGIN stmts . END ELSE COLON BEGIN stmts END

    END             shift and go to state 176


state 166

    (63) stmt -> IF NAME EQEQ NAME COLON BEGIN stmts . END

    END             shift and go to state 177


state 167

    (65) stmt -> IF NAME EQEQ NUMBER COLON BEGIN stmts . END

    END             shift and go to state 178


state 168

    (64) stmt -> IF NAME LT NAME COLON BEGIN stmts . END

    END             shift and go to state 179


state 169

    (54) stmt -> PROC NAME LPAREN params RPAREN COLON BEGIN . stmts END
    (2) stmts -> . stmt stmts
    (3) stmts -> .
    (4) stmt -> . NAME EQUALS MEMREF
    (5) stmt -> . MEMREF EQUALS NAME
    (6) stmt -> . NAME EQUALS NUMBER
    (7) stmt -> . NAME EQUALS NAME
    (8) stmt -> . NAME EQUALS NAME PLUS NAME
    (9) stmt -> . NAME EQUALS NAME MINUS NAME
    (10) stmt -> . NAME EQUALS NAME PLUS NUMBER
    (11) stmt -> . NAME EQUALS NAME MINUS NUMBER
    (12) stmt -> . NAME EQUALS NAME TIMES NAME
    (13) stmt -> . NAME EQUALS NAME TIMES NUMBER
    (14) stmt -> . NAME EQUALS expr
    (15) stmt -> . NAME ASSIGN_OP expr
    (16) stmt -> . REGISTER EQUALS expr
    (17) stmt -> . REGISTER ASSIGN_OP expr
    (27) stmt -> . NAME LBRACKET NUMBER RBRACKET EQUALS expr
    (28) stmt -> . NAME LBRACKET NUMBER RBRACKET ASSIGN_OP expr
    (29) stmt -> . WHILE NAME NE NAME COLON BEGIN stmts END
    (30) stmt -> . WHILE NAME NE NUMBER COLON BEGIN stmts END
    (31) stmt -> . WHILE NAME LT NAME COLON BEGIN stmts END
    (32) stmt -> . WHILE NAME LT NUMBER COLON BEGIN stmts END
    (48) stmt -> . IF cond COLON BEGIN stmts END
    (49) stmt -> . WHILE cond COLON BEGIN stmts END
    (50) stmt -> . WHILE NAME GT NAME COLON BEGIN stmts END
    (51) stmt -> . WHILE NAME GT NUMBER COLON BEGIN stmts END
    (52) stmt -> . VAR NAME
    (53) stmt -> . VAR NAME LBRACKET NUMBER RBRACKET
    (54) stmt -> . PROC NAME LPAREN params RPAREN COLON BEGIN stmts END
    (58) stmt -> . CALL NAME LPAREN args RPAREN
    (62) stmt -> . IF NAME GT NAME COLON BEGIN stmts END
    (63) stmt -> . IF NAME EQEQ NAME COLON BEGIN stmts END
    (64) stmt -> . IF NAME LT NAME COLON BEGIN stmts END
    (65) stmt -> . IF NAME EQEQ NUMBER COLON BEGIN stmts END
    (66) stmt -> . IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END
    (67) stmt -> . NAME asm_args

    END             reduce using rule 3 (stmts -> .)
    NAME            shift and go to state 4
    MEMREF          shift and go to state 5
    REGISTER        shift and go to state 6
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    VAR             shift and go to state 9
    PROC            shift and go to state 10
    CALL            shift and go to state 11

    stmts                          shift and go to state 180
    stmt                           shift and go to state 3

state 170

    (29) stmt -> WHILE NAME NE NAME COLON BEGIN stmts END .

    NAME            reduce using rule 29 (stmt -> WHILE NAME NE NAME COLON BEGIN stmts END .)
    MEMREF          reduce using rule 29 (stmt -> WHILE NAME NE NAME COLON BEGIN stmts END .)
    REGISTER        reduce using rule 29 (stmt -> WHILE NAME NE NAME COLON BEGIN stmts END .)
    WHILE           reduce using rule 29 (stmt -> WHILE NAME NE NAME COLON BEGIN stmts END .)
    IF              reduce using rule 29 (stmt -> WHILE NAME NE NAME COLON BEGIN stmts END .)
    VAR             reduce using rule 29 (stmt -> WHILE NAME NE NAME COLON BEGIN stmts END .)
    PROC            reduce using rule 29 (stmt -> WHILE NAME NE NAME COLON BEGIN stmts END .)
    CALL            reduce using rule 29 (stmt -> WHILE NAME NE NAME COLON BEGIN stmts END .)
    $end            reduce using rule 29 (stmt -> WHILE NAME NE NAME COLON BEGIN stmts END .)
    END             reduce using rule 29 (stmt -> WHILE NAME NE NAME COLON BEGIN stmts END .)


state 171

    (30) stmt -> WHILE NAME NE NUMBER COLON BEGIN stmts END .

    NAME            reduce using rule 30 (stmt -> WHILE NAME NE NUMBER COLON BEGIN stmts END .)
    MEMREF          reduce using rule 30 (stmt -> WHILE NAME NE NUMBER COLON BEGIN stmts END .)
    REGISTER        reduce using rule 30 (stmt -> WHILE NAME NE NUMBER COLON BEGIN stmts END .)
    WHILE           reduce using rule 30 (stmt -> WHILE NAME NE NUMBER COLON BEGIN stmts END .)
    IF              reduce using rule 30 (stmt -> WHILE NAME NE NUMBER COLON BEGIN stmts END .)
    VAR             reduce using rule 30 (stmt -> WHILE NAME NE NUMBER COLON BEGIN stmts END .)
    PROC            reduce using rule 30 (stmt -> WHILE NAME NE NUMBER COLON BEGIN stmts END .)
    CALL            reduce using rule 30 (stmt -> WHILE NAME NE NUMBER COLON BEGIN stmts END .)
    $end            reduce using rule 30 (stmt -> WHILE NAME NE NUMBER COLON BEGIN stmts END .)
    END             reduce using rule 30 (stmt -> WHILE NAME NE NUMBER COLON BEGIN stmts END .)


state 172

    (31) stmt -> WHILE NAME LT NAME COLON BEGIN stmts END .

    NAME            reduce using rule 31 (stmt -> WHILE NAME LT NAME COLON BEGIN stmts END .)
    MEMREF          reduce using rule 31 (stmt -> WHILE NAME LT NAME COLON BEGIN stmts END .)
    REGISTER        reduce using rule 31 (stmt -> WHILE NAME LT NAME COLON BEGIN stmts END .)
    WHILE           reduce using rule 31 (stmt -> WHILE NAME LT NAME COLON BEGIN stmts END .)
    IF              reduce using rule 31 (stmt -> WHILE NAME LT NAME COLON BEGIN stmts END .)
    VAR             reduce using rule 31 (stmt -> WHILE NAME LT NAME COLON BEGIN stmts END .)
    PROC            reduce using rule 31 (stmt -> WHILE NAME LT NAME COLON BEGIN stmts END .)
    CALL            reduce using rule 31 (stmt -> WHILE NAME LT NAME COLON BEGIN stmts END .)
    $end            reduce using rule 31 (stmt -> WHILE NAME LT NAME COLON BEGIN stmts END .)
    END             reduce using rule 31 (stmt -> WHILE NAME LT NAME COLON BEGIN stmts END .)


state 173

    (32) stmt -> WHILE NAME LT NUMBER COLON BEGIN stmts END .

    NAME            reduce using rule 32 (stmt -> WHILE NAME LT NUMBER COLON BEGIN stmts END .)
    MEMREF          reduce using rule 32 (stmt -> WHILE NAME LT NUMBER COLON BEGIN stmts END .)
    REGISTER        reduce using rule 32 (stmt -> WHILE NAME LT NUMBER COLON BEGIN stmts END .)
    WHILE           reduce using rule 32 (stmt -> WHILE NAME LT NUMBER COLON BEGIN stmts END .)
    IF              reduce using rule 32 (stmt -> WHILE NAME LT NUMBER COLON BEGIN stmts END .)
    VAR             reduce using rule 32 (stmt -> WHILE NAME LT NUMBER COLON BEGIN stmts END .)
    PROC            reduce using rule 32 (stmt -> WHILE NAME LT NUMBER COLON BEGIN stmts END .)
    CALL            reduce using rule 32 (stmt -> WHILE NAME LT NUMBER COLON BEGIN stmts END .)
    $end            reduce using rule 32 (stmt -> WHILE NAME LT NUMBER COLON BEGIN stmts END .)
    END             reduce using rule 32 (stmt -> WHILE NAME LT NUMBER COLON BEGIN stmts END .)


state 174

    (50) stmt -> WHILE NAME GT NAME COLON BEGIN stmts END .

    NAME            reduce using rule 50 (stmt -> WHILE NAME GT NAME COLON BEGIN stmts END .)
    MEMREF          reduce using rule 50 (stmt -> WHILE NAME GT NAME COLON BEGIN stmts END .)
    REGISTER        reduce using rule 50 (stmt -> WHILE NAME GT NAME COLON BEGIN stmts END .)
    WHILE           reduce using rule 50 (stmt -> WHILE NAME GT NAME COLON BEGIN stmts END .)
    IF              reduce using rule 50 (stmt -> WHILE NAME GT NAME COLON BEGIN stmts END .)
    VAR             reduce using rule 50 (stmt -> WHILE NAME GT NAME COLON BEGIN stmts END .)
    PROC            reduce using rule 50 (stmt -> WHILE NAME GT NAME COLON BEGIN stmts END .)
    CALL            reduce using rule 50 (stmt -> WHILE NAME GT NAME COLON BEGIN stmts END .)
    $end            reduce using rule 50 (stmt -> WHILE NAME GT NAME COLON BEGIN stmts END .)
    END             reduce using rule 50 (stmt -> WHILE NAME GT NAME COLON BEGIN stmts END .)


state 175

    (51) stmt -> WHILE NAME GT NUMBER COLON BEGIN stmts END .

    NAME            reduce using rule 51 (stmt -> WHILE NAME GT NUMBER COLON BEGIN stmts END .)
    MEMREF          reduce using rule 51 (stmt -> WHILE NAME GT NUMBER COLON BEGIN stmts END .)
    REGISTER        reduce using rule 51 (stmt -> WHILE NAME GT NUMBER COLON BEGIN stmts END .)
    WHILE           reduce using rule 51 (stmt -> WHILE NAME GT NUMBER COLON BEGIN stmts END .)
    IF              reduce using rule 51 (stmt -> WHILE NAME GT NUMBER COLON BEGIN stmts END .)
    VAR             reduce using rule 51 (stmt -> WHILE NAME GT NUMBER COLON BEGIN stmts END .)
    PROC            reduce using rule 51 (stmt -> WHILE NAME GT NUMBER COLON BEGIN stmts END .)
    CALL            reduce using rule 51 (stmt -> WHILE NAME GT NUMBER COLON BEGIN stmts END .)
    $end            reduce using rule 51 (stmt -> WHILE NAME GT NUMBER COLON BEGIN stmts END .)
    END             reduce using rule 51 (stmt -> WHILE NAME GT NUMBER COLON BEGIN stmts END .)


state 176

    (62) stmt -> IF NAME GT NAME COLON BEGIN stmts END .
    (66) stmt -> IF NAME GT NAME COLON BEGIN stmts END . ELSE COLON BEGIN stmts END

    NAME            reduce using rule 62 (stmt -> IF NAME GT NAME COLON BEGIN stmts END .)
    MEMREF          reduce using rule 62 (stmt -> IF NAME GT NAME COLON BEGIN stmts END .)
    REGISTER        reduce using rule 62 (stmt -> IF NAME GT NAME COLON BEGIN stmts END .)
    WHILE           reduce using rule 62 (stmt -> IF NAME GT NAME COLON BEGIN stmts END .)
    IF              reduce using rule 62 (stmt -> IF NAME GT NAME COLON BEGIN stmts END .)
    VAR             reduce using rule 62 (stmt -> IF NAME GT NAME COLON BEGIN stmts END .)
    PROC            reduce using rule 62 (stmt -> IF NAME GT NAME COLON BEGIN stmts END .)
    CALL            reduce using rule 62 (stmt -> IF NAME GT NAME COLON BEGIN stmts END .)
    $end            reduce using rule 62 (stmt -> IF NAME GT NAME COLON BEGIN stmts END .)
    END             reduce using rule 62 (stmt -> IF NAME GT NAME COLON BEGIN stmts END .)
    ELSE            shift and go to state 181


state 177

    (63) stmt -> IF NAME EQEQ NAME COLON BEGIN stmts END .

    NAME            reduce using rule 63 (stmt -> IF NAME EQEQ NAME COLON BEGIN stmts END .)
    MEMREF          reduce using rule 63 (stmt -> IF NAME EQEQ NAME COLON BEGIN stmts END .)
    REGISTER        reduce using rule 63 (stmt -> IF NAME EQEQ NAME COLON BEGIN stmts END .)
    WHILE           reduce using rule 63 (stmt -> IF NAME EQEQ NAME COLON BEGIN stmts END .)
    IF              reduce using rule 63 (stmt -> IF NAME EQEQ NAME COLON BEGIN stmts END .)
    VAR             reduce using rule 63 (stmt -> IF NAME EQEQ NAME COLON BEGIN stmts END .)
    PROC            reduce using rule 63 (stmt -> IF NAME EQEQ NAME COLON BEGIN stmts END .)
    CALL            reduce using rule 63 (stmt -> IF NAME EQEQ NAME COLON BEGIN stmts END .)
    $end            reduce using rule 63 (stmt -> IF NAME EQEQ NAME COLON BEGIN stmts END .)
    END             reduce using rule 63 (stmt -> IF NAME EQEQ NAME COLON BEGIN stmts END .)


state 178

    (65) stmt -> IF NAME EQEQ NUMBER COLON BEGIN stmts END .

    NAME            reduce using rule 65 (stmt -> IF NAME EQEQ NUMBER COLON BEGIN stmts END .)
    MEMREF          reduce using rule 65 (stmt -> IF NAME EQEQ NUMBER COLON BEGIN stmts END .)
    REGISTER        reduce using rule 65 (stmt -> IF NAME EQEQ NUMBER COLON BEGIN stmts END .)
    WHILE           reduce using rule 65 (stmt -> IF NAME EQEQ NUMBER COLON BEGIN stmts END .)
    IF              reduce using rule 65 (stmt -> IF NAME EQEQ NUMBER COLON BEGIN stmts END .)
    VAR             reduce using rule 65 (stmt -> IF NAME EQEQ NUMBER COLON BEGIN stmts END .)
    PROC            reduce using rule 65 (stmt -> IF NAME EQEQ NUMBER COLON BEGIN stmts END .)
    CALL            reduce using rule 65 (stmt -> IF NAME EQEQ NUMBER COLON BEGIN stmts END .)
    $end            reduce using rule 65 (stmt -> IF NAME EQEQ NUMBER COLON BEGIN stmts END .)
    END             reduce using rule 65 (stmt -> IF NAME EQEQ NUMBER COLON BEGIN stmts END .)


state 179

    (64) stmt -> IF NAME LT NAME COLON BEGIN stmts END .

    NAME            reduce using rule 64 (stmt -> IF NAME LT NAME COLON BEGIN stmts END .)
    MEMREF          reduce using rule 64 (stmt -> IF NAME LT NAME COLON BEGIN stmts END .)
    REGISTER        reduce using rule 64 (stmt -> IF NAME LT NAME COLON BEGIN stmts END .)
    WHILE           reduce using rule 64 (stmt -> IF NAME LT NAME COLON BEGIN stmts END .)
    IF              reduce using rule 64 (stmt -> IF NAME LT NAME COLON BEGIN stmts END .)
    VAR             reduce using rule 64 (stmt -> IF NAME LT NAME COLON BEGIN stmts END .)
    PROC            reduce using rule 64 (stmt -> IF NAME LT NAME COLON BEGIN stmts END .)
    CALL            reduce using rule 64 (stmt -> IF NAME LT NAME COLON BEGIN stmts END .)
    $end            reduce using rule 64 (stmt -> IF NAME LT NAME COLON BEGIN stmts END .)
    END             reduce using rule 64 (stmt -> IF NAME LT NAME COLON BEGIN stmts END .)


state 180

    (54) stmt -> PROC NAME LPAREN params RPAREN COLON BEGIN stmts . END

    END             shift and go to state 182


state 181

    (66) stmt -> IF NAME GT NAME COLON BEGIN stmts END ELSE . COLON BEGIN stmts END

    COLON           shift and go to state 183


state 182

    (54) stmt -> PROC NAME LPAREN params RPAREN COLON BEGIN stmts END .

    NAME            reduce using rule 54 (stmt -> PROC NAME LPAREN params RPAREN COLON BEGIN stmts END .)
    MEMREF          reduce using rule 54 (stmt -> PROC NAME LPAREN params RPAREN COLON BEGIN stmts END .)
    REGISTER        reduce using rule 54 (stmt -> PROC NAME LPAREN params RPAREN COLON BEGIN stmts END .)
    WHILE           reduce using rule 54 (stmt -> PROC NAME LPAREN params RPAREN COLON BEGIN stmts END .)
    IF              reduce using rule 54 (stmt -> PROC NAME LPAREN params RPAREN COLON BEGIN stmts END .)
    VAR             reduce using rule 54 (stmt -> PROC NAME LPAREN params RPAREN COLON BEGIN stmts END .)
    PROC            reduce using rule 54 (stmt -> PROC NAME LPAREN params RPAREN COLON BEGIN stmts END .)
    CALL            reduce using rule 54 (stmt -> PROC NAME LPAREN params RPAREN COLON BEGIN stmts END .)
    $end            reduce using rule 54 (stmt -> PROC NAME LPAREN params RPAREN COLON BEGIN stmts END .)
    END             reduce using rule 54 (stmt -> PROC NAME LPAREN params RPAREN COLON BEGIN stmts END .)


state 183

    (66) stmt -> IF NAME GT NAME COLON BEGIN stmts END ELSE COLON . BEGIN stmts END

    BEGIN           shift and go to state 184


state 184

    (66) stmt -> IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN . stmts END
    (2) stmts -> . stmt stmts
    (3) stmts -> .
    (4) stmt -> . NAME EQUALS MEMREF
    (5) stmt -> . MEMREF EQUALS NAME
    (6) stmt -> . NAME EQUALS NUMBER
    (7) stmt -> . NAME EQUALS NAME
    (8) stmt -> . NAME EQUALS NAME PLUS NAME
    (9) stmt -> . NAME EQUALS NAME MINUS NAME
    (10) stmt -> . NAME EQUALS NAME PLUS NUMBER
    (11) stmt -> . NAME EQUALS NAME MINUS NUMBER
    (12) stmt -> . NAME EQUALS NAME TIMES NAME
    (13) stmt -> . NAME EQUALS NAME TIMES NUMBER
    (14) stmt -> . NAME EQUALS expr
    (15) stmt -> . NAME ASSIGN_OP expr
    (16) stmt -> . REGISTER EQUALS expr
    (17) stmt -> . REGISTER ASSIGN_OP expr
    (27) stmt -> . NAME LBRACKET NUMBER RBRACKET EQUALS expr
    (28) stmt -> . NAME LBRACKET NUMBER RBRACKET ASSIGN_OP expr
    (29) stmt -> . WHILE NAME NE NAME COLON BEGIN stmts END
    (30) stmt -> . WHILE NAME NE NUMBER COLON BEGIN stmts END
    (31) stmt -> . WHILE NAME LT NAME COLON BEGIN stmts END
    (32) stmt -> . WHILE NAME LT NUMBER COLON BEGIN stmts END
    (48) stmt -> . IF cond COLON BEGIN stmts END
    (49) stmt -> . WHILE cond COLON BEGIN stmts END
    (50) stmt -> . WHILE NAME GT NAME COLON BEGIN stmts END
    (51) stmt -> . WHILE NAME GT NUMBER COLON BEGIN stmts END
    (52) stmt -> . VAR NAME
    (53) stmt -> . VAR NAME LBRACKET NUMBER RBRACKET
    (54) stmt -> . PROC NAME LPAREN params RPAREN COLON BEGIN stmts END
    (58) stmt -> . CALL NAME LPAREN args RPAREN
    (62) stmt -> . IF NAME GT NAME COLON BEGIN stmts END
    (63) stmt -> . IF NAME EQEQ NAME COLON BEGIN stmts END
    (64) stmt -> . IF NAME LT NAME COLON BEGIN stmts END
    (65) stmt -> . IF NAME EQEQ NUMBER COLON BEGIN stmts END
    (66) stmt -> . IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END
    (67) stmt -> . NAME asm_args

    END             reduce using rule 3 (stmts -> .)
    NAME            shift and go to state 4
    MEMREF          shift and go to state 5
    REGISTER        shift and go to state 6
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    VAR             shift and go to state 9
    PROC            shift and go to state 10
    CALL            shift and go to state 11

    stmts                          shift and go to state 185
    stmt                           shift and go to state 3

state 185

    (66) stmt -> IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts . END

    END             shift and go to state 186


state 186

    (66) stmt -> IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END .

    NAME            reduce using rule 66 (stmt -> IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END .)
    MEMREF          reduce using rule 66 (stmt -> IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END .)
    REGISTER        reduce using rule 66 (stmt -> IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END .)
    WHILE           reduce using rule 66 (stmt -> IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END .)
    IF              reduce using rule 66 (stmt -> IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END .)
    VAR             reduce using rule 66 (stmt -> IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END .)
    PROC            reduce using rule 66 (stmt -> IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END .)
    CALL            reduce using rule 66 (stmt -> IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END .)
    $end            reduce using rule 66 (stmt -> IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END .)
    END             reduce using rule 66 (stmt -> IF NAME GT NAME COLON BEGIN stmts END ELSE COLON BEGIN stmts END .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for REGISTER in state 4 resolved as shift
WARNING: shift/reduce conflict for MEMREF in state 4 resolved as shift
WARNING: shift/reduce conflict for NAME in state 4 resolved as shift
WARNING: shift/reduce conflict for REGISTER in state 20 resolved as shift
WARNING: shift/reduce conflict for MEMREF in state 20 resolved as shift
WARNING: shift/reduce conflict for NAME in state 20 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 34 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 34 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 34 resolved as shift
WARNING: shift/reduce conflict for COLON in state 78 resolved as shift
WARNING: shift/reduce conflict for COLON in state 79 resolved as shift
WARNING: shift/reduce conflict for COLON in state 80 resolved as shift
WARNING: shift/reduce conflict for COLON in state 81 resolved as shift
WARNING: shift/reduce conflict for COLON in state 82 resolved as shift
WARNING: shift/reduce conflict for COLON in state 83 resolved as shift
WARNING: shift/reduce conflict for COLON in state 96 resolved as shift
WARNING: shift/reduce conflict for COLON in state 98 resolved as shift
WARNING: shift/reduce conflict for COLON in state 99 resolved as shift
WARNING: shift/reduce conflict for COLON in state 100 resolved as shift
WARNING: reduce/reduce conflict in state 34 resolved using rule (stmt -> NAME EQUALS NAME)
WARNING: rejected rule (expr -> NAME) in state 34
WARNING: reduce/reduce conflict in state 35 resolved using rule (stmt -> NAME EQUALS MEMREF)
WARNING: rejected rule (expr -> MEMREF) in state 35
WARNING: reduce/reduce conflict in state 36 resolved using rule (stmt -> NAME EQUALS NUMBER)
WARNING: rejected rule (expr -> NUMBER) in state 36
